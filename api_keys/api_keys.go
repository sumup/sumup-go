// Code generated by `go-sdk-gen`. DO NOT EDIT.

package api_keys

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"time"

	"github.com/sumup/sumup-go/client"
)

// Apikey: An API key is a static token that allows you to authorize with SumUp APIs.
// Keep your API keys secret and safe. Do not share your API keys or expose them in a publicly accessible areas
// such as client-side code (browser or apps) or in the GitHub.
type Apikey struct {
	// The timestamp of when the API key was created.
	CreatedAt time.Time `json:"created_at"`
	// Unique identifier of the API Key.
	Id string `json:"id"`
	// User-assigned name of the API Key.
	Name string `json:"name"`
	// The plaintext value of the API key. This field is returned only in the response to API key creation and is
	// never again available in the plaintext form.
	Plaintext *string `json:"plaintext,omitempty"`
	// Last 8 characters of the API key.
	Preview string `json:"preview"`
	// Max items: 128
	Scopes Oauth2Scopes `json:"scopes"`
	Type   ApikeyType   `json:"type"`
	// The timestamp of when the API key was last updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ApikeyType is a schema definition.
type ApikeyType string

const (
	ApikeyTypePublic ApikeyType = "public"
	ApikeyTypeSecret ApikeyType = "secret"
)

// ApikeysList: List of API keys.
type ApikeysList struct {
	// List of API keys.
	Items []Apikey `json:"items"`
	// Total number of API keys.
	TotalCount int `json:"total_count"`
}

// Oauth2Scope is a schema definition.
type Oauth2Scope string

const (
	Oauth2ScopeAccountingRead      Oauth2Scope = "accounting.read"
	Oauth2ScopeAccountingWrite     Oauth2Scope = "accounting.write"
	Oauth2ScopeEmail               Oauth2Scope = "email"
	Oauth2ScopeInvoicesRead        Oauth2Scope = "invoices.read"
	Oauth2ScopeInvoicesWrite       Oauth2Scope = "invoices.write"
	Oauth2ScopePaymentInstruments  Oauth2Scope = "payment_instruments"
	Oauth2ScopePayments            Oauth2Scope = "payments"
	Oauth2ScopeProducts            Oauth2Scope = "products"
	Oauth2ScopeProfile             Oauth2Scope = "profile"
	Oauth2ScopeReadersRead         Oauth2Scope = "readers.read"
	Oauth2ScopeReadersWrite        Oauth2Scope = "readers.write"
	Oauth2ScopeTransactionsHistory Oauth2Scope = "transactions.history"
	Oauth2ScopeUserAppSettings     Oauth2Scope = "user.app-settings"
	Oauth2ScopeUserPayoutSettings  Oauth2Scope = "user.payout-settings"
	Oauth2ScopeUserProfile         Oauth2Scope = "user.profile"
	Oauth2ScopeUserProfileReadonly Oauth2Scope = "user.profile_readonly"
	Oauth2ScopeUserSubaccounts     Oauth2Scope = "user.subaccounts"
)

// Oauth2Scopes is a schema definition.
// Max items: 128
type Oauth2Scopes []Oauth2Scope

// CreateApikeyBody is a schema definition.
type CreateApikeyBody struct {
	// Name of the API key.
	// Max length: 255
	Name string `json:"name"`
	// Max items: 128
	Scopes Oauth2Scopes `json:"scopes"`
}

// UpdateApikeyBody is a schema definition.
type UpdateApikeyBody struct {
	// New name for the API key.
	// Max length: 255
	Name string `json:"name"`
	// Max items: 128
	Scopes Oauth2Scopes `json:"scopes"`
}

// ListApikeysParams: query parameters for ListAPIKeys
type ListApikeysParams struct {
	// Maximum number of keys to return.
	Limit *int
	// Offset of the first key to return.
	Offset *int
}

// QueryValues converts [ListApikeysParams] into [url.Values].
func (p *ListApikeysParams) QueryValues() url.Values {
	q := make(url.Values)

	if p.Limit != nil {
		q.Set("limit", strconv.Itoa(*p.Limit))
	}

	if p.Offset != nil {
		q.Set("offset", strconv.Itoa(*p.Offset))
	}

	return q
}

type ApiKeysService struct {
	c *client.Client
}

func NewApiKeysService(c *client.Client) *ApiKeysService {
	return &ApiKeysService{c: c}
}

// ListApikeys: List API keys
// Returns paginated list of API keys.
func (s *ApiKeysService) ListApikeys(ctx context.Context, merchantCode string, params ListApikeysParams) (*ApikeysList, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/api-keys", merchantCode)

	resp, err := s.c.Call(ctx, http.MethodGet, path, client.WithQueryValues(params.QueryValues()))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v ApikeysList
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// CreateApikey: Create an API key
// Create a new API key.
func (s *ApiKeysService) CreateApikey(ctx context.Context, merchantCode string, body CreateApikeyBody) (*Apikey, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/api-keys", merchantCode)

	resp, err := s.c.Call(ctx, http.MethodPost, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v Apikey
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// DeleteApikey: Delete an API key
// Delete an API key.
func (s *ApiKeysService) DeleteApikey(ctx context.Context, merchantCode string, keyId string) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/api-keys/%v", merchantCode, keyId)

	resp, err := s.c.Call(ctx, http.MethodDelete, path)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNoContent:
		return nil
	default:
		return fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// GetApikey: Retrieve an API Key
// Gets an API key.
func (s *ApiKeysService) GetApikey(ctx context.Context, merchantCode string, keyId string) (*Apikey, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/api-keys/%v", merchantCode, keyId)

	resp, err := s.c.Call(ctx, http.MethodGet, path)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v Apikey
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// UpdateApikey: Update an API key
// Updates an API key.
func (s *ApiKeysService) UpdateApikey(ctx context.Context, merchantCode string, keyId string, body UpdateApikeyBody) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/api-keys/%v", merchantCode, keyId)

	resp, err := s.c.Call(ctx, http.MethodPut, path, client.WithJSONBody(body))
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNoContent:
		return nil
	default:
		return fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}
