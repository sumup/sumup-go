// Code generated by `go-sdk-gen`. DO NOT EDIT.

package sumup

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"time"

	"github.com/sumup/sumup-go/client"
	"github.com/sumup/sumup-go/internal/ptr"
	"github.com/sumup/sumup-go/nullable"
)

// __Required when payment type is `card`.__ Details of the payment card.
type Card struct {
	// Three or four-digit card verification value (security code) of the payment card.
	// Write only
	// Min length: 3
	// Max length: 4
	Cvv string `json:"cvv"`
	// Month from the expiration time of the payment card. Accepted format is `MM`.
	// Write only
	ExpiryMonth CardExpiryMonth `json:"expiry_month"`
	// Year from the expiration time of the payment card. Accepted formats are `YY` and `YYYY`.
	// Write only
	// Min length: 2
	// Max length: 4
	ExpiryYear string `json:"expiry_year"`
	// Last 4 digits of the payment card number.
	// Read only
	// Min length: 4
	// Max length: 4
	Last4Digits string `json:"last_4_digits"`
	// Name of the cardholder as it appears on the payment card.
	// Write only
	Name string `json:"name"`
	// Number of the payment card (without spaces).
	// Write only
	Number string `json:"number"`
	// Issuing card network of the payment card used for the transaction.
	Type CardType `json:"type"`
	// Required five-digit ZIP code. Applicable only to merchant users in the USA.
	// Write only
	// Min length: 5
	// Max length: 5
	ZipCode *string `json:"zip_code,omitempty"`
}

// Month from the expiration time of the payment card. Accepted format is `MM`.
// Write only
type CardExpiryMonth string

const (
	CardExpiryMonth01 CardExpiryMonth = "01"
	CardExpiryMonth02 CardExpiryMonth = "02"
	CardExpiryMonth03 CardExpiryMonth = "03"
	CardExpiryMonth04 CardExpiryMonth = "04"
	CardExpiryMonth05 CardExpiryMonth = "05"
	CardExpiryMonth06 CardExpiryMonth = "06"
	CardExpiryMonth07 CardExpiryMonth = "07"
	CardExpiryMonth08 CardExpiryMonth = "08"
	CardExpiryMonth09 CardExpiryMonth = "09"
	CardExpiryMonth10 CardExpiryMonth = "10"
	CardExpiryMonth11 CardExpiryMonth = "11"
	CardExpiryMonth12 CardExpiryMonth = "12"
)

// Details of the payment checkout.
type Checkout struct {
	// Amount of the payment.
	Amount *float32 `json:"amount,omitempty"`
	// Unique ID of the payment checkout specified by the client application when creating the checkout resource.
	// Max length: 90
	CheckoutReference *string `json:"checkout_reference,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *Currency `json:"currency,omitempty"`
	// Unique identification of a customer. If specified, the checkout session and payment instrument are associated with
	// the referenced customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Date and time of the creation of the payment checkout. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Date *time.Time `json:"date,omitempty"`
	// Short description of the checkout visible in the SumUp dashboard. The description can contribute to reporting, allowing
	// easier identification of a checkout.
	Description *string `json:"description,omitempty"`
	// Unique ID of the checkout resource.
	// Read only
	ID *string `json:"id,omitempty"`
	// Created mandate
	Mandate *MandateResponse `json:"mandate,omitempty"`
	// Unique identifying code of the merchant profile.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// URL to which the SumUp platform sends the processing status of the payment checkout.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// Current status of the checkout.
	Status *CheckoutStatus `json:"status,omitempty"`
	// List of transactions related to the payment.
	// Unique items only
	Transactions []CheckoutTransaction `json:"transactions,omitempty"`
	// Date and time of the checkout expiration before which the client application needs to send a processing request.
	// If no value is present, the checkout does not have an expiration time.
	ValidUntil nullable.Field[time.Time] `json:"valid_until,omitzero"`
}

// Current status of the checkout.
type CheckoutStatus string

const (
	CheckoutStatusExpired CheckoutStatus = "EXPIRED"
	CheckoutStatusFailed  CheckoutStatus = "FAILED"
	CheckoutStatusPaid    CheckoutStatus = "PAID"
	CheckoutStatusPending CheckoutStatus = "PENDING"
)

// CheckoutTransaction is a schema definition.
type CheckoutTransaction struct {
	// Total amount of the transaction.
	Amount *float32 `json:"amount,omitempty"`
	// Authorization code for the transaction sent by the payment card issuer or bank. Applicable only to card payments.
	AuthCode *string `json:"auth_code,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *Currency `json:"currency,omitempty"`
	// Entry mode of the payment details.
	EntryMode *EntryMode `json:"entry_mode,omitempty"`
	// Unique ID of the transaction.
	ID *string `json:"id,omitempty"`
	// Current number of the installment for deferred payments.
	// Min: 1
	InstallmentsCount *int `json:"installments_count,omitempty"`
	// Internal unique ID of the transaction on the SumUp platform.
	// Format: int64
	InternalID *int64 `json:"internal_id,omitempty"`
	// Unique code of the registered merchant to whom the payment is made.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Payment type used for the transaction.
	PaymentType *PaymentType `json:"payment_type,omitempty"`
	// Current status of the transaction.
	Status *CheckoutTransactionStatus `json:"status,omitempty"`
	// Date and time of the creation of the transaction. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Timestamp *time.Time `json:"timestamp,omitempty"`
	// Amount of the tip (out of the total transaction amount).
	TipAmount *float32 `json:"tip_amount,omitempty"`
	// Transaction code returned by the acquirer/processing entity after processing the transaction.
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Amount of the applicable VAT (out of the total transaction amount).
	VATAmount *float32 `json:"vat_amount,omitempty"`
}

// Current status of the transaction.
type CheckoutTransactionStatus string

const (
	CheckoutTransactionStatusCancelled  CheckoutTransactionStatus = "CANCELLED"
	CheckoutTransactionStatusFailed     CheckoutTransactionStatus = "FAILED"
	CheckoutTransactionStatusPending    CheckoutTransactionStatus = "PENDING"
	CheckoutTransactionStatusSuccessful CheckoutTransactionStatus = "SUCCESSFUL"
)

// 3DS Response
type CheckoutAccepted struct {
	// Required action processing 3D Secure payments.
	NextStep *CheckoutAcceptedNextStep `json:"next_step,omitempty"`
}

// Required action processing 3D Secure payments.
type CheckoutAcceptedNextStep struct {
	// Indicates allowed mechanisms for redirecting an end user. If both values are provided to ensure a redirect takes
	// place in either.
	Mechanism []CheckoutAcceptedNextStepMechanism `json:"mechanism,omitempty"`
	// Method used to complete the redirect.
	Method *string `json:"method,omitempty"`
	// Contains parameters essential for form redirection. Number of object keys and their content can vary.
	Payload *CheckoutAcceptedNextStepPayload `json:"payload,omitempty"`
	// Refers to a url where the end user is redirected once the payment processing completes.
	RedirectURL *string `json:"redirect_url,omitempty"`
	// Where the end user is redirected.
	URL *string `json:"url,omitempty"`
}

// CheckoutAcceptedNextStepMechanism is a schema definition.
type CheckoutAcceptedNextStepMechanism string

const (
	CheckoutAcceptedNextStepMechanismBrowser CheckoutAcceptedNextStepMechanism = "browser"
	CheckoutAcceptedNextStepMechanismIframe  CheckoutAcceptedNextStepMechanism = "iframe"
)

// Contains parameters essential for form redirection. Number of object keys and their content can vary.
type CheckoutAcceptedNextStepPayload struct {
	Md      *any `json:"md,omitempty"`
	PaReq   *any `json:"pa_req,omitempty"`
	TermURL *any `json:"term_url,omitempty"`
}

// Details of the payment checkout.
type CheckoutCreateRequest struct {
	// Amount of the payment.
	Amount float32 `json:"amount"`
	// Unique ID of the payment checkout specified by the client application when creating the checkout resource.
	// Max length: 90
	CheckoutReference string `json:"checkout_reference"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency Currency `json:"currency"`
	// Unique identification of a customer. If specified, the checkout session and payment instrument are associated with
	// the referenced customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Date and time of the creation of the payment checkout. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	//
	// Read only
	Date *time.Time `json:"date,omitempty"`
	// Short description of the checkout visible in the SumUp dashboard. The description can contribute to reporting, allowing
	// easier identification of a checkout.
	Description *string `json:"description,omitempty"`
	// Unique ID of the checkout resource.
	// Read only
	ID *string `json:"id,omitempty"`
	// Unique identifying code of the merchant profile.
	MerchantCode string `json:"merchant_code"`
	// Purpose of the checkout.
	// Default: CHECKOUT
	Purpose *CheckoutCreateRequestPurpose `json:"purpose,omitempty"`
	// __Required__ for [APMs](https://developer.sumup.com/online-payments/apm/introduction) and __recommended__ for
	// card payments. Refers to a url where the end user is redirected once the payment processing completes. If
	// not specified, the [Payment Widget](https://developer.sumup.com/online-payments/tools/card-widget) renders [3DS
	// challenge](https://developer.sumup.com/online-payments/features/3ds) within an iframe instead of performing a
	// full-page redirect.
	RedirectURL *string `json:"redirect_url,omitempty"`
	// URL to which the SumUp platform sends the processing status of the payment checkout.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// Current status of the checkout.
	// Read only
	Status *CheckoutCreateRequestStatus `json:"status,omitempty"`
	// List of transactions related to the payment.
	// Read only
	// Unique items only
	Transactions []CheckoutCreateRequestTransaction `json:"transactions,omitempty"`
	// Date and time of the checkout expiration before which the client application needs to send a processing request.
	// If no value is present, the checkout does not have an expiration time.
	ValidUntil nullable.Field[time.Time] `json:"valid_until,omitzero"`
}

// Purpose of the checkout.
// Default: CHECKOUT
type CheckoutCreateRequestPurpose string

const (
	CheckoutCreateRequestPurposeCheckout              CheckoutCreateRequestPurpose = "CHECKOUT"
	CheckoutCreateRequestPurposeSetupRecurringPayment CheckoutCreateRequestPurpose = "SETUP_RECURRING_PAYMENT"
)

// Current status of the checkout.
// Read only
type CheckoutCreateRequestStatus string

const (
	CheckoutCreateRequestStatusFailed  CheckoutCreateRequestStatus = "FAILED"
	CheckoutCreateRequestStatusPaid    CheckoutCreateRequestStatus = "PAID"
	CheckoutCreateRequestStatusPending CheckoutCreateRequestStatus = "PENDING"
)

// CheckoutCreateRequestTransaction is a schema definition.
type CheckoutCreateRequestTransaction struct {
	// Total amount of the transaction.
	Amount *float32 `json:"amount,omitempty"`
	// Authorization code for the transaction sent by the payment card issuer or bank. Applicable only to card payments.
	AuthCode *string `json:"auth_code,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *Currency `json:"currency,omitempty"`
	// Entry mode of the payment details.
	EntryMode *EntryMode `json:"entry_mode,omitempty"`
	// Unique ID of the transaction.
	ID *string `json:"id,omitempty"`
	// Current number of the installment for deferred payments.
	// Min: 1
	InstallmentsCount *int `json:"installments_count,omitempty"`
	// Internal unique ID of the transaction on the SumUp platform.
	// Format: int64
	InternalID *int64 `json:"internal_id,omitempty"`
	// Unique code of the registered merchant to whom the payment is made.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Payment type used for the transaction.
	PaymentType *PaymentType `json:"payment_type,omitempty"`
	// Current status of the transaction.
	Status *CheckoutCreateRequestTransactionStatus `json:"status,omitempty"`
	// Date and time of the creation of the transaction. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Timestamp *time.Time `json:"timestamp,omitempty"`
	// Amount of the tip (out of the total transaction amount).
	TipAmount *float32 `json:"tip_amount,omitempty"`
	// Transaction code returned by the acquirer/processing entity after processing the transaction.
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Amount of the applicable VAT (out of the total transaction amount).
	VATAmount *float32 `json:"vat_amount,omitempty"`
}

// Current status of the transaction.
type CheckoutCreateRequestTransactionStatus string

const (
	CheckoutCreateRequestTransactionStatusCancelled  CheckoutCreateRequestTransactionStatus = "CANCELLED"
	CheckoutCreateRequestTransactionStatusFailed     CheckoutCreateRequestTransactionStatus = "FAILED"
	CheckoutCreateRequestTransactionStatusPending    CheckoutCreateRequestTransactionStatus = "PENDING"
	CheckoutCreateRequestTransactionStatusSuccessful CheckoutCreateRequestTransactionStatus = "SUCCESSFUL"
)

// CheckoutSuccess is a schema definition.
type CheckoutSuccess struct {
	// Amount of the payment.
	Amount *float32 `json:"amount,omitempty"`
	// Unique ID of the payment checkout specified by the client application when creating the checkout resource.
	// Max length: 90
	CheckoutReference *string `json:"checkout_reference,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *Currency `json:"currency,omitempty"`
	// Unique identification of a customer. If specified, the checkout session and payment instrument are associated with
	// the referenced customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Date and time of the creation of the payment checkout. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Date *time.Time `json:"date,omitempty"`
	// Short description of the checkout visible in the SumUp dashboard. The description can contribute to reporting, allowing
	// easier identification of a checkout.
	Description *string `json:"description,omitempty"`
	// Unique ID of the checkout resource.
	// Read only
	ID *string `json:"id,omitempty"`
	// Created mandate
	Mandate *MandateResponse `json:"mandate,omitempty"`
	// Unique identifying code of the merchant profile.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Name of the merchant
	MerchantName *string `json:"merchant_name,omitempty"`
	// Object containing token information for the specified payment instrument
	PaymentInstrument *CheckoutSuccessPaymentInstrument `json:"payment_instrument,omitempty"`
	// Refers to a url where the end user is redirected once the payment processing completes.
	RedirectURL *string `json:"redirect_url,omitempty"`
	// URL to which the SumUp platform sends the processing status of the payment checkout.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// Current status of the checkout.
	Status *CheckoutSuccessStatus `json:"status,omitempty"`
	// Transaction code of the successful transaction with which the payment for the checkout is completed.
	// Read only
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Transaction ID of the successful transaction with which the payment for the checkout is completed.
	// Read only
	TransactionID *string `json:"transaction_id,omitempty"`
	// List of transactions related to the payment.
	// Unique items only
	Transactions []CheckoutSuccessTransaction `json:"transactions,omitempty"`
	// Date and time of the checkout expiration before which the client application needs to send a processing request.
	// If no value is present, the checkout does not have an expiration time.
	ValidUntil nullable.Field[time.Time] `json:"valid_until,omitzero"`
}

// Current status of the checkout.
type CheckoutSuccessStatus string

const (
	CheckoutSuccessStatusExpired CheckoutSuccessStatus = "EXPIRED"
	CheckoutSuccessStatusFailed  CheckoutSuccessStatus = "FAILED"
	CheckoutSuccessStatusPaid    CheckoutSuccessStatus = "PAID"
	CheckoutSuccessStatusPending CheckoutSuccessStatus = "PENDING"
)

// CheckoutSuccessTransaction is a schema definition.
type CheckoutSuccessTransaction struct {
	// Total amount of the transaction.
	Amount *float32 `json:"amount,omitempty"`
	// Authorization code for the transaction sent by the payment card issuer or bank. Applicable only to card payments.
	AuthCode *string `json:"auth_code,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *Currency `json:"currency,omitempty"`
	// Entry mode of the payment details.
	EntryMode *EntryMode `json:"entry_mode,omitempty"`
	// Unique ID of the transaction.
	ID *string `json:"id,omitempty"`
	// Current number of the installment for deferred payments.
	// Min: 1
	InstallmentsCount *int `json:"installments_count,omitempty"`
	// Internal unique ID of the transaction on the SumUp platform.
	// Format: int64
	InternalID *int64 `json:"internal_id,omitempty"`
	// Unique code of the registered merchant to whom the payment is made.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Payment type used for the transaction.
	PaymentType *PaymentType `json:"payment_type,omitempty"`
	// Current status of the transaction.
	Status *CheckoutSuccessTransactionStatus `json:"status,omitempty"`
	// Date and time of the creation of the transaction. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Timestamp *time.Time `json:"timestamp,omitempty"`
	// Amount of the tip (out of the total transaction amount).
	TipAmount *float32 `json:"tip_amount,omitempty"`
	// Transaction code returned by the acquirer/processing entity after processing the transaction.
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Amount of the applicable VAT (out of the total transaction amount).
	VATAmount *float32 `json:"vat_amount,omitempty"`
}

// Current status of the transaction.
type CheckoutSuccessTransactionStatus string

const (
	CheckoutSuccessTransactionStatusCancelled  CheckoutSuccessTransactionStatus = "CANCELLED"
	CheckoutSuccessTransactionStatusFailed     CheckoutSuccessTransactionStatus = "FAILED"
	CheckoutSuccessTransactionStatusPending    CheckoutSuccessTransactionStatus = "PENDING"
	CheckoutSuccessTransactionStatusSuccessful CheckoutSuccessTransactionStatus = "SUCCESSFUL"
)

// Object containing token information for the specified payment instrument
type CheckoutSuccessPaymentInstrument struct {
	// Token value
	Token *string `json:"token,omitempty"`
}

// Error message structure.
type DetailsError struct {
	// Details of the error.
	Details           *string                        `json:"details,omitempty"`
	FailedConstraints []DetailsErrorFailedConstraint `json:"failed_constraints,omitempty"`
	// The status code.
	Status *float64 `json:"status,omitempty"`
	// Short title of the error.
	Title *string `json:"title,omitempty"`
}

// DetailsErrorFailedConstraint is a schema definition.
type DetailsErrorFailedConstraint struct {
	Message   *string `json:"message,omitempty"`
	Reference *string `json:"reference,omitempty"`
}

func (e *DetailsError) Error() string {
	return fmt.Sprintf("details=%v, failed_constraints=%v, status=%v, title=%v", ptr.OrNil(e.Details), e.FailedConstraints, ptr.OrNil(e.Status), ptr.OrNil(e.Title))
}

var _ error = (*DetailsError)(nil)

// ErrorExtended is a schema definition.
type ErrorExtended struct {
	// Platform code for the error.
	ErrorCode *string `json:"error_code,omitempty"`
	// Short description of the error.
	Message *string `json:"message,omitempty"`
	// Parameter name (with relative location) to which the error applies. Parameters from embedded resources are
	// displayed using dot notation. For example, `card.name` refers to the `name` parameter embedded in the `card`
	// object.
	Param *string `json:"param,omitempty"`
}

func (e *ErrorExtended) Error() string {
	return fmt.Sprintf("error_code=%v, message=%v, param=%v", ptr.OrNil(e.ErrorCode), ptr.OrNil(e.Message), ptr.OrNil(e.Param))
}

var _ error = (*ErrorExtended)(nil)

// Mandate is passed when a card is to be tokenized
type MandatePayload struct {
	// Indicates the mandate type
	Type MandatePayloadType `json:"type"`
	// Operating system and web client used by the end-user
	UserAgent string `json:"user_agent"`
	// IP address of the end user. Supports IPv4 and IPv6
	UserIP *string `json:"user_ip,omitempty"`
}

// Indicates the mandate type
type MandatePayloadType string

const (
	MandatePayloadTypeRecurrent MandatePayloadType = "recurrent"
)

// Details of the payment instrument for processing the checkout.
type ProcessCheckout struct {
	// __Required when payment type is `card`.__ Details of the payment card.
	Card *Card `json:"card,omitempty"`
	// __Required when `token` is provided.__ Unique ID of the customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Number of installments for deferred payments. Available only to merchant users in Brazil.
	// Min: 1
	// Max: 12
	Installments *int `json:"installments,omitempty"`
	// Mandate is passed when a card is to be tokenized
	Mandate *MandatePayload `json:"mandate,omitempty"`
	// Describes the payment method used to attempt processing
	PaymentType ProcessCheckoutPaymentType `json:"payment_type"`
	// Personal details for the customer.
	PersonalDetails *PersonalDetails `json:"personal_details,omitempty"`
	// __Required when using a tokenized card to process a checkout.__ Unique token identifying the saved payment card
	// for a customer.
	Token *string `json:"token,omitempty"`
}

// Describes the payment method used to attempt processing
type ProcessCheckoutPaymentType string

const (
	ProcessCheckoutPaymentTypeBancontact ProcessCheckoutPaymentType = "bancontact"
	ProcessCheckoutPaymentTypeBlik       ProcessCheckoutPaymentType = "blik"
	ProcessCheckoutPaymentTypeBoleto     ProcessCheckoutPaymentType = "boleto"
	ProcessCheckoutPaymentTypeCard       ProcessCheckoutPaymentType = "card"
	ProcessCheckoutPaymentTypeIdeal      ProcessCheckoutPaymentType = "ideal"
)

type CheckoutsCreateParams = CheckoutCreateRequest

type CheckoutsProcessParams = ProcessCheckout

// CheckoutsListParams are query parameters for ListCheckouts.
type CheckoutsListParams struct {
	// Filters the list of checkout resources by the unique ID of the checkout.
	CheckoutReference *string
}

// QueryValues converts [CheckoutsListParams] into [url.Values].
func (p *CheckoutsListParams) QueryValues() url.Values {
	q := make(url.Values)

	if p.CheckoutReference != nil {
		q.Set("checkout_reference", *p.CheckoutReference)
	}

	return q
}

// CheckoutsListAvailablePaymentMethodsParams are query parameters for GetPaymentMethods.
type CheckoutsListAvailablePaymentMethodsParams struct {
	// The amount for which the payment methods should be eligible, in major units. Note that currency must also
	// be provided when filtering by amount.
	Amount *float64
	// The currency for which the payment methods should be eligible.
	Currency *string
}

// QueryValues converts [CheckoutsListAvailablePaymentMethodsParams] into [url.Values].
func (p *CheckoutsListAvailablePaymentMethodsParams) QueryValues() url.Values {
	q := make(url.Values)

	if p.Amount != nil {
		q.Set("amount", strconv.FormatFloat(*p.Amount, 'f', -1, 64))
	}

	if p.Currency != nil {
		q.Set("currency", *p.Currency)
	}

	return q
}

// CheckoutsListResponse is a schema definition.
type CheckoutsListResponse []CheckoutSuccess

// CheckoutsListAvailablePaymentMethodsResponse is a schema definition.
type CheckoutsListAvailablePaymentMethodsResponse struct {
	AvailablePaymentMethods []CheckoutsListAvailablePaymentMethodsResponseAvailablePaymentMethod `json:"available_payment_methods,omitempty"`
}

// CheckoutsListAvailablePaymentMethodsResponseAvailablePaymentMethod is a schema definition.
type CheckoutsListAvailablePaymentMethodsResponseAvailablePaymentMethod struct {
	// The ID of the payment method.
	ID string `json:"id"`
}

// CheckoutsProcess400Response is a schema definition.
type CheckoutsProcess400Response json.RawMessage

func (e *CheckoutsProcess400Response) Error() string {
	return "CheckoutsProcess400Response"
}

var _ error = (*CheckoutsProcess400Response)(nil)

type CheckoutsProcessResponse struct {
	CheckoutSuccess  *CheckoutSuccess
	CheckoutAccepted *CheckoutAccepted
}

func (r *CheckoutsProcessResponse) AsCheckoutSuccess() (*CheckoutSuccess, bool) {
	if r.CheckoutSuccess != nil {
		return r.CheckoutSuccess, true
	}

	return nil, false
}

func (r *CheckoutsProcessResponse) AsCheckoutAccepted() (*CheckoutAccepted, bool) {
	if r.CheckoutAccepted != nil {
		return r.CheckoutAccepted, true
	}

	return nil, false
}

type CheckoutsClient struct {
	c *client.Client
}

func NewCheckoutsClient(c *client.Client) *CheckoutsClient {
	return &CheckoutsClient{c: c}
}

// Lists created checkout resources according to the applied `checkout_reference`.
func (c *CheckoutsClient) List(ctx context.Context, params CheckoutsListParams) (*CheckoutsListResponse, error) {
	path := fmt.Sprintf("/v0.1/checkouts")

	resp, err := c.c.Call(ctx, http.MethodGet, path, client.WithQueryValues(params.QueryValues()))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v CheckoutsListResponse
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusUnauthorized:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Creates a new payment checkout resource. The unique `checkout_reference` created by this request, is used
// for further manipulation of the checkout.
//
// For 3DS checkouts, add the `redirect_url` parameter to your request body schema.
//
// Follow by processing a checkout to charge the provided payment instrument.
func (c *CheckoutsClient) Create(ctx context.Context, body CheckoutsCreateParams) (*Checkout, error) {
	path := fmt.Sprintf("/v0.1/checkouts")

	resp, err := c.c.Call(ctx, http.MethodPost, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v Checkout
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr ErrorExtended
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusForbidden:
		var apiErr ErrorForbidden
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusConflict:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Get payment methods available for the given merchant to use with a checkout.
func (c *CheckoutsClient) ListAvailablePaymentMethods(ctx context.Context, merchantCode string, params CheckoutsListAvailablePaymentMethodsParams) (*CheckoutsListAvailablePaymentMethodsResponse, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/payment-methods", merchantCode)

	resp, err := c.c.Call(ctx, http.MethodGet, path, client.WithQueryValues(params.QueryValues()))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v CheckoutsListAvailablePaymentMethodsResponse
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr DetailsError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Deactivates an identified checkout resource. If the checkout has already been processed it can not be deactivated.
func (c *CheckoutsClient) Deactivate(ctx context.Context, id string) (*Checkout, error) {
	path := fmt.Sprintf("/v0.1/checkouts/%v", id)

	resp, err := c.c.Call(ctx, http.MethodDelete, path)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v Checkout
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusUnauthorized:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusConflict:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Retrieves an identified checkout resource. Use this request after processing a checkout to confirm its status
// and inform the end user respectively.
func (c *CheckoutsClient) Get(ctx context.Context, id string) (*CheckoutSuccess, error) {
	path := fmt.Sprintf("/v0.1/checkouts/%v", id)

	resp, err := c.c.Call(ctx, http.MethodGet, path)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v CheckoutSuccess
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusUnauthorized:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Processing a checkout will attempt to charge the provided payment instrument for the amount of the specified checkout
// resource initiated in the `Create a checkout` endpoint.
//
// Follow this request with `Retrieve a checkout` to confirm its status.
func (c *CheckoutsClient) Process(ctx context.Context, id string, body CheckoutsProcessParams) (*CheckoutsProcessResponse, error) {
	path := fmt.Sprintf("/v0.1/checkouts/%v", id)

	resp, err := c.c.Call(ctx, http.MethodPut, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v CheckoutSuccess
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &CheckoutsProcessResponse{
			CheckoutSuccess: &v,
		}, nil
	case http.StatusAccepted:
		var v CheckoutAccepted
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &CheckoutsProcessResponse{
			CheckoutAccepted: &v,
		}, nil
	case http.StatusBadRequest:
		var apiErr CheckoutsProcess400Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusConflict:
		var apiErr Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}
