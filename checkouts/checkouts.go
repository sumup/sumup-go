// Code generated by `go-sdk-gen`. DO NOT EDIT.

package checkouts

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"time"

	"github.com/sumup/sumup-go/client"
	"github.com/sumup/sumup-go/shared"
)

// Card: __Required when payment type is `card`.__ Details of the payment card.
type Card struct {
	// Three or four-digit card verification value (security code) of the payment card.
	// Write only
	// Min length: 3
	// Max length: 4
	Cvv string `json:"cvv"`
	// Month from the expiration time of the payment card. Accepted format is `MM`.
	// Write only
	ExpiryMonth CardExpiryMonth `json:"expiry_month"`
	// Year from the expiration time of the payment card. Accepted formats are `YY` and `YYYY`.
	// Write only
	// Min length: 2
	// Max length: 4
	ExpiryYear string `json:"expiry_year"`
	// Last 4 digits of the payment card number.
	// Read only
	// Min length: 4
	// Max length: 4
	Last4Digits string `json:"last_4_digits"`
	// Name of the cardholder as it appears on the payment card.
	// Write only
	Name string `json:"name"`
	// Number of the payment card (without spaces).
	// Write only
	Number string `json:"number"`
	// Issuing card network of the payment card used for the transaction.
	Type shared.CardType `json:"type"`
	// Required five-digit ZIP code. Applicable only to merchant users in the USA.
	// Write only
	// Min length: 5
	// Max length: 5
	ZipCode *string `json:"zip_code,omitempty"`
}

// CardExpiryMonth: Month from the expiration time of the payment card. Accepted format is `MM`.
// Write only
type CardExpiryMonth string

const (
	CardExpiryMonth01 CardExpiryMonth = "01"
	CardExpiryMonth02 CardExpiryMonth = "02"
	CardExpiryMonth03 CardExpiryMonth = "03"
	CardExpiryMonth04 CardExpiryMonth = "04"
	CardExpiryMonth05 CardExpiryMonth = "05"
	CardExpiryMonth06 CardExpiryMonth = "06"
	CardExpiryMonth07 CardExpiryMonth = "07"
	CardExpiryMonth08 CardExpiryMonth = "08"
	CardExpiryMonth09 CardExpiryMonth = "09"
	CardExpiryMonth10 CardExpiryMonth = "10"
	CardExpiryMonth11 CardExpiryMonth = "11"
	CardExpiryMonth12 CardExpiryMonth = "12"
)

// Checkout: Details of the payment checkout.
type Checkout struct {
	// Amount of the payment.
	Amount *float32 `json:"amount,omitempty"`
	// Unique ID of the payment checkout specified by the client application when creating the checkout resource.
	// Max length: 90
	CheckoutReference *string `json:"checkout_reference,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *shared.Currency `json:"currency,omitempty"`
	// Unique identification of a customer. If specified, the checkout session and payment instrument are associated with
	// the referenced customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Date and time of the creation of the payment checkout. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Date *time.Time `json:"date,omitempty"`
	// Short description of the checkout visible in the SumUp dashboard. The description can contribute to reporting, allowing
	// easier identification of a checkout.
	Description *string `json:"description,omitempty"`
	// Unique ID of the checkout resource.
	// Read only
	ID *string `json:"id,omitempty"`
	// Created mandate
	Mandate *shared.MandateResponse `json:"mandate,omitempty"`
	// Unique identifying code of the merchant profile.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// URL to which the SumUp platform sends the processing status of the payment checkout.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// Current status of the checkout.
	Status *CheckoutStatus `json:"status,omitempty"`
	// List of transactions related to the payment.
	// Unique items only
	Transactions []CheckoutTransaction `json:"transactions,omitempty"`
	// Date and time of the checkout expiration before which the client application needs to send a processing request.
	// If no value is present, the checkout does not have an expiration time.
	ValidUntil *time.Time `json:"valid_until,omitempty"`
}

// CheckoutStatus: Current status of the checkout.
type CheckoutStatus string

const (
	CheckoutStatusExpired CheckoutStatus = "EXPIRED"
	CheckoutStatusFailed  CheckoutStatus = "FAILED"
	CheckoutStatusPaid    CheckoutStatus = "PAID"
	CheckoutStatusPending CheckoutStatus = "PENDING"
)

// CheckoutTransaction is a schema definition.
type CheckoutTransaction struct {
	// Total amount of the transaction.
	Amount *float32 `json:"amount,omitempty"`
	// Authorization code for the transaction sent by the payment card issuer or bank. Applicable only to card payments.
	AuthCode *string `json:"auth_code,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *shared.Currency `json:"currency,omitempty"`
	// Entry mode of the payment details.
	EntryMode *shared.EntryMode `json:"entry_mode,omitempty"`
	// Unique ID of the transaction.
	ID *string `json:"id,omitempty"`
	// Current number of the installment for deferred payments.
	// Min: 1
	InstallmentsCount *int `json:"installments_count,omitempty"`
	// Internal unique ID of the transaction on the SumUp platform.
	// Format: int64
	InternalID *int64 `json:"internal_id,omitempty"`
	// Unique code of the registered merchant to whom the payment is made.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Payment type used for the transaction.
	PaymentType *shared.PaymentType `json:"payment_type,omitempty"`
	// Current status of the transaction.
	Status *CheckoutTransactionStatus `json:"status,omitempty"`
	// Date and time of the creation of the transaction. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Timestamp *time.Time `json:"timestamp,omitempty"`
	// Amount of the tip (out of the total transaction amount).
	TipAmount *float32 `json:"tip_amount,omitempty"`
	// Transaction code returned by the acquirer/processing entity after processing the transaction.
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Amount of the applicable VAT (out of the total transaction amount).
	VATAmount *float32 `json:"vat_amount,omitempty"`
}

// CheckoutTransactionStatus: Current status of the transaction.
type CheckoutTransactionStatus string

const (
	CheckoutTransactionStatusCancelled  CheckoutTransactionStatus = "CANCELLED"
	CheckoutTransactionStatusFailed     CheckoutTransactionStatus = "FAILED"
	CheckoutTransactionStatusPending    CheckoutTransactionStatus = "PENDING"
	CheckoutTransactionStatusSuccessful CheckoutTransactionStatus = "SUCCESSFUL"
)

// CheckoutAccepted: 3DS Response
type CheckoutAccepted struct {
	// Required action processing 3D Secure payments.
	NextStep *CheckoutAcceptedNextStep `json:"next_step,omitempty"`
}

// CheckoutAcceptedNextStep: Required action processing 3D Secure payments.
type CheckoutAcceptedNextStep struct {
	// Indicates allowed mechanisms for redirecting an end user. If both values are provided to ensure a redirect takes
	// place in either.
	Mechanism []CheckoutAcceptedNextStepMechanism `json:"mechanism,omitempty"`
	// Method used to complete the redirect.
	Method *string `json:"method,omitempty"`
	// Contains parameters essential for form redirection. Number of object keys and their content can vary.
	Payload *CheckoutAcceptedNextStepPayload `json:"payload,omitempty"`
	// Refers to a url where the end user is redirected once the payment processing completes.
	RedirectURL *string `json:"redirect_url,omitempty"`
	// Where the end user is redirected.
	URL *string `json:"url,omitempty"`
}

// CheckoutAcceptedNextStepMechanism is a schema definition.
type CheckoutAcceptedNextStepMechanism string

const (
	CheckoutAcceptedNextStepMechanismBrowser CheckoutAcceptedNextStepMechanism = "browser"
	CheckoutAcceptedNextStepMechanismIframe  CheckoutAcceptedNextStepMechanism = "iframe"
)

// CheckoutAcceptedNextStepPayload: Contains parameters essential for form redirection. Number of object keys
// and their content can vary.
type CheckoutAcceptedNextStepPayload struct {
	Md      *any `json:"md,omitempty"`
	PaReq   *any `json:"pa_req,omitempty"`
	TermURL *any `json:"term_url,omitempty"`
}

// CheckoutCreateRequest: Details of the payment checkout.
type CheckoutCreateRequest struct {
	// Amount of the payment.
	Amount float32 `json:"amount"`
	// Unique ID of the payment checkout specified by the client application when creating the checkout resource.
	// Max length: 90
	CheckoutReference string `json:"checkout_reference"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency shared.Currency `json:"currency"`
	// Unique identification of a customer. If specified, the checkout session and payment instrument are associated with
	// the referenced customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Date and time of the creation of the payment checkout. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	//
	// Read only
	Date *time.Time `json:"date,omitempty"`
	// Short description of the checkout visible in the SumUp dashboard. The description can contribute to reporting, allowing
	// easier identification of a checkout.
	Description *string `json:"description,omitempty"`
	// Unique ID of the checkout resource.
	// Read only
	ID *string `json:"id,omitempty"`
	// Unique identifying code of the merchant profile.
	MerchantCode string `json:"merchant_code"`
	// Purpose of the checkout.
	// Default: CHECKOUT
	Purpose *CheckoutCreateRequestPurpose `json:"purpose,omitempty"`
	// __Required__ for [APMs](https://developer.sumup.com/online-payments/apm/introduction) and __recommended__ for
	// card payments. Refers to a url where the end user is redirected once the payment processing completes. If
	// not specified, the [Payment Widget](https://developer.sumup.com/online-payments/tools/card-widget) renders [3DS
	// challenge](https://developer.sumup.com/online-payments/features/3ds) within an iframe instead of performing a
	// full-page redirect.
	RedirectURL *string `json:"redirect_url,omitempty"`
	// URL to which the SumUp platform sends the processing status of the payment checkout.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// Current status of the checkout.
	// Read only
	Status *CheckoutCreateRequestStatus `json:"status,omitempty"`
	// List of transactions related to the payment.
	// Read only
	// Unique items only
	Transactions []CheckoutCreateRequestTransaction `json:"transactions,omitempty"`
	// Date and time of the checkout expiration before which the client application needs to send a processing request.
	// If no value is present, the checkout does not have an expiration time.
	ValidUntil *time.Time `json:"valid_until,omitempty"`
}

// CheckoutCreateRequestPurpose: Purpose of the checkout.
// Default: CHECKOUT
type CheckoutCreateRequestPurpose string

const (
	CheckoutCreateRequestPurposeCheckout              CheckoutCreateRequestPurpose = "CHECKOUT"
	CheckoutCreateRequestPurposeSetupRecurringPayment CheckoutCreateRequestPurpose = "SETUP_RECURRING_PAYMENT"
)

// CheckoutCreateRequestStatus: Current status of the checkout.
// Read only
type CheckoutCreateRequestStatus string

const (
	CheckoutCreateRequestStatusFailed  CheckoutCreateRequestStatus = "FAILED"
	CheckoutCreateRequestStatusPaid    CheckoutCreateRequestStatus = "PAID"
	CheckoutCreateRequestStatusPending CheckoutCreateRequestStatus = "PENDING"
)

// CheckoutCreateRequestTransaction is a schema definition.
type CheckoutCreateRequestTransaction struct {
	// Total amount of the transaction.
	Amount *float32 `json:"amount,omitempty"`
	// Authorization code for the transaction sent by the payment card issuer or bank. Applicable only to card payments.
	AuthCode *string `json:"auth_code,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *shared.Currency `json:"currency,omitempty"`
	// Entry mode of the payment details.
	EntryMode *shared.EntryMode `json:"entry_mode,omitempty"`
	// Unique ID of the transaction.
	ID *string `json:"id,omitempty"`
	// Current number of the installment for deferred payments.
	// Min: 1
	InstallmentsCount *int `json:"installments_count,omitempty"`
	// Internal unique ID of the transaction on the SumUp platform.
	// Format: int64
	InternalID *int64 `json:"internal_id,omitempty"`
	// Unique code of the registered merchant to whom the payment is made.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Payment type used for the transaction.
	PaymentType *shared.PaymentType `json:"payment_type,omitempty"`
	// Current status of the transaction.
	Status *CheckoutCreateRequestTransactionStatus `json:"status,omitempty"`
	// Date and time of the creation of the transaction. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Timestamp *time.Time `json:"timestamp,omitempty"`
	// Amount of the tip (out of the total transaction amount).
	TipAmount *float32 `json:"tip_amount,omitempty"`
	// Transaction code returned by the acquirer/processing entity after processing the transaction.
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Amount of the applicable VAT (out of the total transaction amount).
	VATAmount *float32 `json:"vat_amount,omitempty"`
}

// CheckoutCreateRequestTransactionStatus: Current status of the transaction.
type CheckoutCreateRequestTransactionStatus string

const (
	CheckoutCreateRequestTransactionStatusCancelled  CheckoutCreateRequestTransactionStatus = "CANCELLED"
	CheckoutCreateRequestTransactionStatusFailed     CheckoutCreateRequestTransactionStatus = "FAILED"
	CheckoutCreateRequestTransactionStatusPending    CheckoutCreateRequestTransactionStatus = "PENDING"
	CheckoutCreateRequestTransactionStatusSuccessful CheckoutCreateRequestTransactionStatus = "SUCCESSFUL"
)

// CheckoutSuccess is a schema definition.
type CheckoutSuccess struct {
	// Amount of the payment.
	Amount *float32 `json:"amount,omitempty"`
	// Unique ID of the payment checkout specified by the client application when creating the checkout resource.
	// Max length: 90
	CheckoutReference *string `json:"checkout_reference,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *shared.Currency `json:"currency,omitempty"`
	// Unique identification of a customer. If specified, the checkout session and payment instrument are associated with
	// the referenced customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Date and time of the creation of the payment checkout. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Date *time.Time `json:"date,omitempty"`
	// Short description of the checkout visible in the SumUp dashboard. The description can contribute to reporting, allowing
	// easier identification of a checkout.
	Description *string `json:"description,omitempty"`
	// Unique ID of the checkout resource.
	// Read only
	ID *string `json:"id,omitempty"`
	// Created mandate
	Mandate *shared.MandateResponse `json:"mandate,omitempty"`
	// Unique identifying code of the merchant profile.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Name of the merchant
	MerchantName *string `json:"merchant_name,omitempty"`
	// Object containing token information for the specified payment instrument
	PaymentInstrument *CheckoutSuccessPaymentInstrument `json:"payment_instrument,omitempty"`
	// Refers to a url where the end user is redirected once the payment processing completes.
	RedirectURL *string `json:"redirect_url,omitempty"`
	// URL to which the SumUp platform sends the processing status of the payment checkout.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// Current status of the checkout.
	Status *CheckoutSuccessStatus `json:"status,omitempty"`
	// Transaction code of the successful transaction with which the payment for the checkout is completed.
	// Read only
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Transaction ID of the successful transaction with which the payment for the checkout is completed.
	// Read only
	TransactionID *string `json:"transaction_id,omitempty"`
	// List of transactions related to the payment.
	// Unique items only
	Transactions []CheckoutSuccessTransaction `json:"transactions,omitempty"`
	// Date and time of the checkout expiration before which the client application needs to send a processing request.
	// If no value is present, the checkout does not have an expiration time.
	ValidUntil *time.Time `json:"valid_until,omitempty"`
}

// CheckoutSuccessStatus: Current status of the checkout.
type CheckoutSuccessStatus string

const (
	CheckoutSuccessStatusExpired CheckoutSuccessStatus = "EXPIRED"
	CheckoutSuccessStatusFailed  CheckoutSuccessStatus = "FAILED"
	CheckoutSuccessStatusPaid    CheckoutSuccessStatus = "PAID"
	CheckoutSuccessStatusPending CheckoutSuccessStatus = "PENDING"
)

// CheckoutSuccessTransaction is a schema definition.
type CheckoutSuccessTransaction struct {
	// Total amount of the transaction.
	Amount *float32 `json:"amount,omitempty"`
	// Authorization code for the transaction sent by the payment card issuer or bank. Applicable only to card payments.
	AuthCode *string `json:"auth_code,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *shared.Currency `json:"currency,omitempty"`
	// Entry mode of the payment details.
	EntryMode *shared.EntryMode `json:"entry_mode,omitempty"`
	// Unique ID of the transaction.
	ID *string `json:"id,omitempty"`
	// Current number of the installment for deferred payments.
	// Min: 1
	InstallmentsCount *int `json:"installments_count,omitempty"`
	// Internal unique ID of the transaction on the SumUp platform.
	// Format: int64
	InternalID *int64 `json:"internal_id,omitempty"`
	// Unique code of the registered merchant to whom the payment is made.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Payment type used for the transaction.
	PaymentType *shared.PaymentType `json:"payment_type,omitempty"`
	// Current status of the transaction.
	Status *CheckoutSuccessTransactionStatus `json:"status,omitempty"`
	// Date and time of the creation of the transaction. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Timestamp *time.Time `json:"timestamp,omitempty"`
	// Amount of the tip (out of the total transaction amount).
	TipAmount *float32 `json:"tip_amount,omitempty"`
	// Transaction code returned by the acquirer/processing entity after processing the transaction.
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Amount of the applicable VAT (out of the total transaction amount).
	VATAmount *float32 `json:"vat_amount,omitempty"`
}

// CheckoutSuccessTransactionStatus: Current status of the transaction.
type CheckoutSuccessTransactionStatus string

const (
	CheckoutSuccessTransactionStatusCancelled  CheckoutSuccessTransactionStatus = "CANCELLED"
	CheckoutSuccessTransactionStatusFailed     CheckoutSuccessTransactionStatus = "FAILED"
	CheckoutSuccessTransactionStatusPending    CheckoutSuccessTransactionStatus = "PENDING"
	CheckoutSuccessTransactionStatusSuccessful CheckoutSuccessTransactionStatus = "SUCCESSFUL"
)

// CheckoutSuccessPaymentInstrument: Object containing token information for the specified payment instrument
type CheckoutSuccessPaymentInstrument struct {
	// Token value
	Token *string `json:"token,omitempty"`
}

// DetailsError: Error message structure.
type DetailsError struct {
	// Details of the error.
	Details           *string                        `json:"details,omitempty"`
	FailedConstraints []DetailsErrorFailedConstraint `json:"failed_constraints,omitempty"`
	// The status code.
	Status *float64 `json:"status,omitempty"`
	// Short title of the error.
	Title *string `json:"title,omitempty"`
}

// DetailsErrorFailedConstraint is a schema definition.
type DetailsErrorFailedConstraint struct {
	Message   *string `json:"message,omitempty"`
	Reference *string `json:"reference,omitempty"`
}

func (e *DetailsError) Error() string {
	return fmt.Sprintf("details=%v, failed_constraints=%v, status=%v, title=%v", e.Details, e.FailedConstraints, e.Status, e.Title)
}

var _ error = (*DetailsError)(nil)

// ErrorExtended is a schema definition.
type ErrorExtended struct {
	// Platform code for the error.
	ErrorCode *string `json:"error_code,omitempty"`
	// Short description of the error.
	Message *string `json:"message,omitempty"`
	// Parameter name (with relative location) to which the error applies. Parameters from embedded resources are
	// displayed using dot notation. For example, `card.name` refers to the `name` parameter embedded in the `card`
	// object.
	Param *string `json:"param,omitempty"`
}

func (e *ErrorExtended) Error() string {
	return fmt.Sprintf("error_code=%v, message=%v, param=%v", e.ErrorCode, e.Message, e.Param)
}

var _ error = (*ErrorExtended)(nil)

// MandatePayload: Mandate is passed when a card is to be tokenized
type MandatePayload struct {
	// Indicates the mandate type
	Type MandatePayloadType `json:"type"`
	// Operating system and web client used by the end-user
	UserAgent string `json:"user_agent"`
	// IP address of the end user. Supports IPv4 and IPv6
	UserIP *string `json:"user_ip,omitempty"`
}

// MandatePayloadType: Indicates the mandate type
type MandatePayloadType string

const (
	MandatePayloadTypeRecurrent MandatePayloadType = "recurrent"
)

// ProcessCheckout: Details of the payment instrument for processing the checkout.
type ProcessCheckout struct {
	// __Required when payment type is `card`.__ Details of the payment card.
	Card *Card `json:"card,omitempty"`
	// __Required when `token` is provided.__ Unique ID of the customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Number of installments for deferred payments. Available only to merchant users in Brazil.
	// Min: 1
	// Max: 12
	Installments *int `json:"installments,omitempty"`
	// Mandate is passed when a card is to be tokenized
	Mandate *MandatePayload `json:"mandate,omitempty"`
	// Describes the payment method used to attempt processing
	PaymentType ProcessCheckoutPaymentType `json:"payment_type"`
	// Personal details for the customer.
	PersonalDetails *shared.PersonalDetails `json:"personal_details,omitempty"`
	// __Required when using a tokenized card to process a checkout.__ Unique token identifying the saved payment card
	// for a customer.
	Token *string `json:"token,omitempty"`
}

// ProcessCheckoutPaymentType: Describes the payment method used to attempt processing
type ProcessCheckoutPaymentType string

const (
	ProcessCheckoutPaymentTypeBancontact ProcessCheckoutPaymentType = "bancontact"
	ProcessCheckoutPaymentTypeBlik       ProcessCheckoutPaymentType = "blik"
	ProcessCheckoutPaymentTypeBoleto     ProcessCheckoutPaymentType = "boleto"
	ProcessCheckoutPaymentTypeCard       ProcessCheckoutPaymentType = "card"
	ProcessCheckoutPaymentTypeIdeal      ProcessCheckoutPaymentType = "ideal"
)

// Create: Details of the payment checkout.
type Create struct {
	// Amount of the payment.
	Amount float32 `json:"amount"`
	// Unique ID of the payment checkout specified by the client application when creating the checkout resource.
	// Max length: 90
	CheckoutReference string `json:"checkout_reference"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency shared.Currency `json:"currency"`
	// Unique identification of a customer. If specified, the checkout session and payment instrument are associated with
	// the referenced customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Date and time of the creation of the payment checkout. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	//
	// Read only
	Date *time.Time `json:"date,omitempty"`
	// Short description of the checkout visible in the SumUp dashboard. The description can contribute to reporting, allowing
	// easier identification of a checkout.
	Description *string `json:"description,omitempty"`
	// Unique ID of the checkout resource.
	// Read only
	ID *string `json:"id,omitempty"`
	// Unique identifying code of the merchant profile.
	MerchantCode string `json:"merchant_code"`
	// Purpose of the checkout.
	// Default: CHECKOUT
	Purpose *CreatePurpose `json:"purpose,omitempty"`
	// __Required__ for [APMs](https://developer.sumup.com/online-payments/apm/introduction) and __recommended__ for
	// card payments. Refers to a url where the end user is redirected once the payment processing completes. If
	// not specified, the [Payment Widget](https://developer.sumup.com/online-payments/tools/card-widget) renders [3DS
	// challenge](https://developer.sumup.com/online-payments/features/3ds) within an iframe instead of performing a
	// full-page redirect.
	RedirectURL *string `json:"redirect_url,omitempty"`
	// URL to which the SumUp platform sends the processing status of the payment checkout.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// Current status of the checkout.
	// Read only
	Status *CreateStatus `json:"status,omitempty"`
	// List of transactions related to the payment.
	// Read only
	// Unique items only
	Transactions []CreateTransaction `json:"transactions,omitempty"`
	// Date and time of the checkout expiration before which the client application needs to send a processing request.
	// If no value is present, the checkout does not have an expiration time.
	ValidUntil *time.Time `json:"valid_until,omitempty"`
}

// CreatePurpose: Purpose of the checkout.
// Default: CHECKOUT
type CreatePurpose string

const (
	CreatePurposeCheckout              CreatePurpose = "CHECKOUT"
	CreatePurposeSetupRecurringPayment CreatePurpose = "SETUP_RECURRING_PAYMENT"
)

// CreateStatus: Current status of the checkout.
// Read only
type CreateStatus string

const (
	CreateStatusFailed  CreateStatus = "FAILED"
	CreateStatusPaid    CreateStatus = "PAID"
	CreateStatusPending CreateStatus = "PENDING"
)

// CreateTransaction is a schema definition.
type CreateTransaction struct {
	// Total amount of the transaction.
	Amount *float32 `json:"amount,omitempty"`
	// Authorization code for the transaction sent by the payment card issuer or bank. Applicable only to card payments.
	AuthCode *string `json:"auth_code,omitempty"`
	// Three-letter [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) code of the currency for the amount. Currently supported
	// currency values are enumerated above.
	Currency *shared.Currency `json:"currency,omitempty"`
	// Entry mode of the payment details.
	EntryMode *shared.EntryMode `json:"entry_mode,omitempty"`
	// Unique ID of the transaction.
	ID *string `json:"id,omitempty"`
	// Current number of the installment for deferred payments.
	// Min: 1
	InstallmentsCount *int `json:"installments_count,omitempty"`
	// Internal unique ID of the transaction on the SumUp platform.
	// Format: int64
	InternalID *int64 `json:"internal_id,omitempty"`
	// Unique code of the registered merchant to whom the payment is made.
	MerchantCode *string `json:"merchant_code,omitempty"`
	// Payment type used for the transaction.
	PaymentType *shared.PaymentType `json:"payment_type,omitempty"`
	// Current status of the transaction.
	Status *CreateTransactionStatus `json:"status,omitempty"`
	// Date and time of the creation of the transaction. Response format expressed according to [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) code.
	Timestamp *time.Time `json:"timestamp,omitempty"`
	// Amount of the tip (out of the total transaction amount).
	TipAmount *float32 `json:"tip_amount,omitempty"`
	// Transaction code returned by the acquirer/processing entity after processing the transaction.
	TransactionCode *string `json:"transaction_code,omitempty"`
	// Amount of the applicable VAT (out of the total transaction amount).
	VATAmount *float32 `json:"vat_amount,omitempty"`
}

// CreateTransactionStatus: Current status of the transaction.
type CreateTransactionStatus string

const (
	CreateTransactionStatusCancelled  CreateTransactionStatus = "CANCELLED"
	CreateTransactionStatusFailed     CreateTransactionStatus = "FAILED"
	CreateTransactionStatusPending    CreateTransactionStatus = "PENDING"
	CreateTransactionStatusSuccessful CreateTransactionStatus = "SUCCESSFUL"
)

// Process: Details of the payment instrument for processing the checkout.
type Process struct {
	// __Required when payment type is `card`.__ Details of the payment card.
	Card *Card `json:"card,omitempty"`
	// __Required when `token` is provided.__ Unique ID of the customer.
	CustomerID *string `json:"customer_id,omitempty"`
	// Number of installments for deferred payments. Available only to merchant users in Brazil.
	// Min: 1
	// Max: 12
	Installments *int `json:"installments,omitempty"`
	// Mandate is passed when a card is to be tokenized
	Mandate *MandatePayload `json:"mandate,omitempty"`
	// Describes the payment method used to attempt processing
	PaymentType ProcessPaymentType `json:"payment_type"`
	// Personal details for the customer.
	PersonalDetails *shared.PersonalDetails `json:"personal_details,omitempty"`
	// __Required when using a tokenized card to process a checkout.__ Unique token identifying the saved payment card
	// for a customer.
	Token *string `json:"token,omitempty"`
}

// ProcessPaymentType: Describes the payment method used to attempt processing
type ProcessPaymentType string

const (
	ProcessPaymentTypeBancontact ProcessPaymentType = "bancontact"
	ProcessPaymentTypeBlik       ProcessPaymentType = "blik"
	ProcessPaymentTypeBoleto     ProcessPaymentType = "boleto"
	ProcessPaymentTypeCard       ProcessPaymentType = "card"
	ProcessPaymentTypeIdeal      ProcessPaymentType = "ideal"
)

// ListParams: query parameters for ListCheckouts
type ListParams struct {
	// Filters the list of checkout resources by the unique ID of the checkout.
	CheckoutReference *string
}

// QueryValues converts [ListParams] into [url.Values].
func (p *ListParams) QueryValues() url.Values {
	q := make(url.Values)

	if p.CheckoutReference != nil {
		q.Set("checkout_reference", *p.CheckoutReference)
	}

	return q
}

// ListAvailablePaymentMethodsParams: query parameters for GetPaymentMethods
type ListAvailablePaymentMethodsParams struct {
	// The amount for which the payment methods should be eligible, in major units. Note that currency must also
	// be provided when filtering by amount.
	Amount *float64
	// The currency for which the payment methods should be eligible.
	Currency *string
}

// QueryValues converts [ListAvailablePaymentMethodsParams] into [url.Values].
func (p *ListAvailablePaymentMethodsParams) QueryValues() url.Values {
	q := make(url.Values)

	if p.Amount != nil {
		q.Set("amount", strconv.FormatFloat(*p.Amount, 'f', -1, 64))
	}

	if p.Currency != nil {
		q.Set("currency", *p.Currency)
	}

	return q
}

// ListCheckouts200Response is a schema definition.
type ListCheckouts200Response []CheckoutSuccess

// GetPaymentMethods200Response is a schema definition.
type GetPaymentMethods200Response struct {
	AvailablePaymentMethods []GetPaymentMethods200ResponseAvailablePaymentMethod `json:"available_payment_methods,omitempty"`
}

// GetPaymentMethods200ResponseAvailablePaymentMethod is a schema definition.
type GetPaymentMethods200ResponseAvailablePaymentMethod struct {
	// The ID of the payment method.
	ID string `json:"id"`
}

// ProcessCheckout400Response is a schema definition.
type ProcessCheckout400Response json.RawMessage

func (e *ProcessCheckout400Response) Error() string {
	return fmt.Sprintf("")
}

var _ error = (*ProcessCheckout400Response)(nil)

type ProcessCheckoutResponse struct {
	CheckoutSuccess  *CheckoutSuccess
	CheckoutAccepted *CheckoutAccepted
}

func (r *ProcessCheckoutResponse) AsCheckoutSuccess() (*CheckoutSuccess, bool) {
	if r.CheckoutSuccess != nil {
		return r.CheckoutSuccess, true
	}

	return nil, false
}

func (r *ProcessCheckoutResponse) AsCheckoutAccepted() (*CheckoutAccepted, bool) {
	if r.CheckoutAccepted != nil {
		return r.CheckoutAccepted, true
	}

	return nil, false
}

type CheckoutsService struct {
	c *client.Client
}

func NewCheckoutsService(c *client.Client) *CheckoutsService {
	return &CheckoutsService{c: c}
}

// List: List checkouts
// Lists created checkout resources according to the applied `checkout_reference`.
func (s *CheckoutsService) List(ctx context.Context, params ListParams) (*ListCheckouts200Response, error) {
	path := fmt.Sprintf("/v0.1/checkouts")

	resp, err := s.c.Call(ctx, http.MethodGet, path, client.WithQueryValues(params.QueryValues()))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v ListCheckouts200Response
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusUnauthorized:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Create: Create a checkout
// Creates a new payment checkout resource. The unique `checkout_reference` created by this request, is used
// for further manipulation of the checkout.
//
// For 3DS checkouts, add the `redirect_url` parameter to your request body schema.
//
// Follow by processing a checkout to charge the provided payment instrument.
func (s *CheckoutsService) Create(ctx context.Context, body Create) (*Checkout, error) {
	path := fmt.Sprintf("/v0.1/checkouts")

	resp, err := s.c.Call(ctx, http.MethodPost, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v Checkout
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr ErrorExtended
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusForbidden:
		var apiErr shared.ErrorForbidden
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusConflict:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// ListAvailablePaymentMethods: Get available payment methods
// Get payment methods available for the given merchant to use with a checkout.
func (s *CheckoutsService) ListAvailablePaymentMethods(ctx context.Context, merchantCode string, params ListAvailablePaymentMethodsParams) (*GetPaymentMethods200Response, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/payment-methods", merchantCode)

	resp, err := s.c.Call(ctx, http.MethodGet, path, client.WithQueryValues(params.QueryValues()))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v GetPaymentMethods200Response
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr DetailsError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Deactivate: Deactivate a checkout
// Deactivates an identified checkout resource. If the checkout has already been processed it can not be deactivated.
func (s *CheckoutsService) Deactivate(ctx context.Context, id string) (*Checkout, error) {
	path := fmt.Sprintf("/v0.1/checkouts/%v", id)

	resp, err := s.c.Call(ctx, http.MethodDelete, path)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v Checkout
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusUnauthorized:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusConflict:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Get: Retrieve a checkout
// Retrieves an identified checkout resource. Use this request after processing a checkout to confirm its status
// and inform the end user respectively.
func (s *CheckoutsService) Get(ctx context.Context, id string) (*CheckoutSuccess, error) {
	path := fmt.Sprintf("/v0.1/checkouts/%v", id)

	resp, err := s.c.Call(ctx, http.MethodGet, path)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v CheckoutSuccess
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusUnauthorized:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Process: Process a checkout
// Processing a checkout will attempt to charge the provided payment instrument for the amount of the specified checkout
// resource initiated in the `Create a checkout` endpoint.
//
// Follow this request with `Retrieve a checkout` to confirm its status.
func (s *CheckoutsService) Process(ctx context.Context, id string, body Process) (*ProcessCheckoutResponse, error) {
	path := fmt.Sprintf("/v0.1/checkouts/%v", id)

	resp, err := s.c.Call(ctx, http.MethodPut, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v CheckoutSuccess
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &ProcessCheckoutResponse{
			CheckoutSuccess: &v,
		}, nil
	case http.StatusAccepted:
		var v CheckoutAccepted
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &ProcessCheckoutResponse{
			CheckoutAccepted: &v,
		}, nil
	case http.StatusBadRequest:
		var apiErr ProcessCheckout400Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusConflict:
		var apiErr shared.Error
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}
