// Code generated by `gogenitor`. DO NOT EDIT.
package sumup

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

// Affiliate is Affiliate metadata for the transaction.
// It is an optional field that allow for integrators to track the source of the transaction.
type Affiliate struct {
	// Application ID of the affiliate.
	// It is a unique identifier for the application and should be set by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	AppId string `json:"app_id"`
	// Foreign transaction ID of the affiliate.
	// It is a unique identifier for the transaction.
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ForeignTransactionId string `json:"foreign_transaction_id"`
	// Key of the affiliate.
	// It is a unique identifier for the key  and should be generated by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	Key string `json:"key"`
	// Additional metadata for the transaction.
	// It is key-value object that can be associated with the transaction.
	Tags *AffiliateTags `json:"tags,omitempty"`
}

// AffiliateTags is Additional metadata for the transaction.
// It is key-value object that can be associated with the transaction.
type AffiliateTags struct {
}

// CreateReaderCheckout is Reader Checkout
type CreateReaderCheckout struct {
	// Affiliate metadata for the transaction.
	// It is an optional field that allow for integrators to track the source of the transaction.
	Affiliate *Affiliate `json:"affiliate,omitempty"`
	// The card type of the card used for the transaction.
	// Is is required only for some countries (e.g: Brazil).
	CardType *CreateReaderCheckoutCardType `json:"card_type,omitempty"`
	// Description of the checkout to be shown in the Merchant Sales
	Description *string `json:"description,omitempty"`
	// Number of installments for the transaction.
	// It may vary according to the merchant country.
	// For example, in Brazil, the maximum number of installments is 12.
	Installments *int `json:"installments,omitempty"`
	// Webhook URL to which the payment result will be sent.
	// It must be a HTTPS url.
	ReturnUrl *string `json:"return_url,omitempty"`
	// List of tipping rates to be displayed to the cardholder.
	// The rates are in percentage and should be between 0.01 and 0.99.
	// The list should be sorted in ascending order.
	TipRates *[]float64 `json:"tip_rates,omitempty"`
	// Amount of the transaction.
	// The amount is represented as an integer value altogether with the currency and the minor unit.
	// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	TotalAmount CreateReaderCheckoutAmount `json:"total_amount"`
}

// The card type of the card used for the transaction.
// Is is required only for some countries (e.g: Brazil).
type CreateReaderCheckoutCardType string

const (
	CreateReaderCheckoutCardTypeCredit CreateReaderCheckoutCardType = "credit"
	CreateReaderCheckoutCardTypeDebit  CreateReaderCheckoutCardType = "debit"
)

// CreateReaderCheckoutAmount is Amount of the transaction.
// The amount is represented as an integer value altogether with the currency and the minor unit.
// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
type CreateReaderCheckoutAmount struct {
	// Currency ISO 4217 code
	Currency string `json:"currency"`
	// The minor units of the currency. It represents the number of decimals of the currency.
	// For the currencies CLP, COP and HUF, the minor unit is 0.
	MinorUnit int `json:"minor_unit"`
	// Total amount of the transaction.
	// It must be a positive integer.
	Value int `json:"value"`
}

// Meta is Set of user-defined key-value pairs attached to the object.
type Meta struct {
}

// Reader is A physical card reader device that can accept in-person payments.
type Reader struct {
	// Reader creation timestamp.
	CreatedAt time.Time `json:"created_at"`
	// Information about the underlying physical device.
	Device ReaderDevice `json:"device"`
	// Unique identifier of the object.
	//
	// Note that this identifies the instance of the physical devices pairing with your SumUp account.
	//
	// If you DELETE a reader, and pair the device again, the ID will be different. Do not use this ID to refer to a physical device.
	Id ReaderId `json:"id"`
	// Set of user-defined key-value pairs attached to the object.
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	Name ReaderName `json:"name"`
	// The status of the reader object gives information about the current state of the reader.
	//
	// Possible values:
	//
	// - `unknown` - The reader status is unknown.
	// - `processing` - The reader is created and waits for the physical device to confirm the pairing.
	// - `paired` - The reader is paired with a merchant account and can be used with SumUp APIs.
	// - `expired` - The pairing is expired and no longer usable with the account. The resource needs to get recreated
	Status ReaderStatus `json:"status"`
	// Reader last-modification timestamp.
	UpdatedAt time.Time `json:"updated_at"`
}

// ReaderDevice is Information about the underlying physical device.
type ReaderDevice struct {
	// A unique identifier of the physical device (e.g. serial number).
	Identifier string `json:"identifier"`
	// Identifier of the model of the device.
	Model ReaderDeviceModel `json:"model"`
}

// Identifier of the model of the device.
type ReaderDeviceModel string

const (
	ReaderDeviceModelSolo        ReaderDeviceModel = "solo"
	ReaderDeviceModelVirtualSolo ReaderDeviceModel = "virtual-solo"
)

// ReaderId is Unique identifier of the object.
//
// Note that this identifies the instance of the physical devices pairing with your SumUp account.
//
// If you DELETE a reader, and pair the device again, the ID will be different. Do not use this ID to refer to a physical device.
type ReaderId string

// ReaderName is Custom human-readable, user-defined name for easier identification of the reader.
type ReaderName string

// ReaderPairingCode is The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiating the pairing.
// It is used to link the physical device to the created pairing.
type ReaderPairingCode string

// The status of the reader object gives information about the current state of the reader.
//
// Possible values:
//
// - `unknown` - The reader status is unknown.
// - `processing` - The reader is created and waits for the physical device to confirm the pairing.
// - `paired` - The reader is paired with a merchant account and can be used with SumUp APIs.
// - `expired` - The pairing is expired and no longer usable with the account. The resource needs to get recreated
type ReaderStatus string

const (
	ReaderStatusExpired    ReaderStatus = "expired"
	ReaderStatusPaired     ReaderStatus = "paired"
	ReaderStatusProcessing ReaderStatus = "processing"
	ReaderStatusUnknown    ReaderStatus = "unknown"
)

// ListReadersResponse is the type definition for a ListReadersResponse.
type ListReadersResponse struct {
	Items []Reader `json:"items"`
}

// CreateReader request body.
type CreateReaderBody struct {
	// Set of user-defined key-value pairs attached to the object.
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	Name *ReaderName `json:"name,omitempty"`
	// The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiating the pairing.
	// It is used to link the physical device to the created pairing.
	PairingCode ReaderPairingCode `json:"pairing_code"`
}

// CreateReaderCheckout request body.
type CreateReaderCheckoutBody struct {
	// Affiliate metadata for the transaction.
	// It is an optional field that allow for integrators to track the source of the transaction.
	Affiliate *Affiliate `json:"affiliate,omitempty"`
	// The card type of the card used for the transaction.
	// Is is required only for some countries (e.g: Brazil).
	CardType *CreateReaderCheckoutBodyCardType `json:"card_type,omitempty"`
	// Description of the checkout to be shown in the Merchant Sales
	Description *string `json:"description,omitempty"`
	// Number of installments for the transaction.
	// It may vary according to the merchant country.
	// For example, in Brazil, the maximum number of installments is 12.
	Installments *int `json:"installments,omitempty"`
	// Webhook URL to which the payment result will be sent.
	// It must be a HTTPS url.
	ReturnUrl *string `json:"return_url,omitempty"`
	// List of tipping rates to be displayed to the cardholder.
	// The rates are in percentage and should be between 0.01 and 0.99.
	// The list should be sorted in ascending order.
	TipRates *[]float64 `json:"tip_rates,omitempty"`
	// Amount of the transaction.
	// The amount is represented as an integer value altogether with the currency and the minor unit.
	// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	TotalAmount CreateReaderCheckoutAmount `json:"total_amount"`
}

// The card type of the card used for the transaction.
// Is is required only for some countries (e.g: Brazil).
type CreateReaderCheckoutBodyCardType string

const (
	CreateReaderCheckoutBodyCardTypeCredit CreateReaderCheckoutBodyCardType = "credit"
	CreateReaderCheckoutBodyCardTypeDebit  CreateReaderCheckoutBodyCardType = "debit"
)

// CreateReaderCheckoutResponse is the type definition for a CreateReaderCheckoutResponse.
type CreateReaderCheckoutResponse struct {
	Data *CreateReaderCheckoutResponseData `json:"data,omitempty"`
}

// CreateReaderCheckoutResponseData is the type definition for a CreateReaderCheckoutResponseData.
type CreateReaderCheckoutResponseData struct {
	// The client transaction ID is a unique identifier for the transaction that is generated for the client.
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ClientTransactionId *string `json:"client_transaction_id,omitempty"`
}

// GetReaderParams are query parameters for GetReader
type GetReaderParams struct {
	IfModifiedSince *string `json:"If-Modified-Since,omitempty"`
}

// UpdateReader request body.
type UpdateReaderBody struct {
	// Set of user-defined key-value pairs attached to the object.
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	Name *ReaderName `json:"name,omitempty"`
}

type ReadersService service

// ListReaders: List Readers
// Returns list of all readers of the merchant.
func (s *ReadersService) ListReaders(ctx context.Context, merchantCode string) (*ListReadersResponse, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers", merchantCode)

	req, err := s.client.NewRequest(ctx, http.MethodGet, path, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 500 {
		return nil, fmt.Errorf("invalid response: %d - %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	dec := json.NewDecoder(resp.Body)
	if resp.StatusCode >= 400 {
		var apiErr APIError
		if err := dec.Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	}

	var v ListReadersResponse
	if err := dec.Decode(&v); err != nil {
		return nil, fmt.Errorf("decode response: %s", err.Error())
	}

	return &v, nil
}

// CreateReader: Create a Reader
// Create a new reader linked to the merchant account.
func (s *ReadersService) CreateReader(ctx context.Context, merchantCode string, body CreateReaderBody) (*Reader, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	path := fmt.Sprintf("/v0.1/merchants/%v/readers", merchantCode)

	req, err := s.client.NewRequest(ctx, http.MethodPost, path, buf)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 500 {
		return nil, fmt.Errorf("invalid response: %d - %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	dec := json.NewDecoder(resp.Body)
	if resp.StatusCode >= 400 {
		var apiErr APIError
		if err := dec.Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	}

	var v Reader
	if err := dec.Decode(&v); err != nil {
		return nil, fmt.Errorf("decode response: %s", err.Error())
	}

	return &v, nil
}

// CreateReaderTerminate: Create a Reader Terminate action
// Create a Terminate action for a Reader.
//
// It stops the current transaction on the target device.
//
// This process is asynchronous and the actual termination may take some time to be performed on the device.
//
// There are some caveats when using this endpoint:
// * The target device must be online, otherwise terminate won't be accepted
// * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting for PIN, etc.
// * There is no confirmation of the termination.
//
// If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status will be sent as `failed` to the provided URL.
//
// **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
func (s *ReadersService) CreateReaderTerminate(ctx context.Context, merchantCode string, id string) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/terminate", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodPost, path, http.NoBody)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 500 {
		return fmt.Errorf("invalid response: %d - %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	dec := json.NewDecoder(resp.Body)
	if resp.StatusCode >= 400 {
		var apiErr APIError
		if err := dec.Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	}

	return nil
}

// CreateReaderCheckout: Create a Reader Checkout
// Create a Checkout for a Reader.
//
// This process is asynchronous and the actual transaction may take some time to be stared on the device.
//
// There are some caveats when using this endpoint:
// * The target device must be online, otherwise checkout won't be accepted
// * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During this time, any other checkout for the same device will be rejected.
//
// **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
func (s *ReadersService) CreateReaderCheckout(ctx context.Context, merchantCode string, id string, body CreateReaderCheckoutBody) (*CreateReaderCheckoutResponse, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/checkout", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodPost, path, buf)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 500 {
		return nil, fmt.Errorf("invalid response: %d - %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	dec := json.NewDecoder(resp.Body)
	if resp.StatusCode >= 400 {
		var apiErr APIError
		if err := dec.Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	}

	var v CreateReaderCheckoutResponse
	if err := dec.Decode(&v); err != nil {
		return nil, fmt.Errorf("decode response: %s", err.Error())
	}

	return &v, nil
}

// DeleteReader: Delete a reader
// Deletes a Reader.
func (s *ReadersService) DeleteReader(ctx context.Context, merchantCode string, id ReaderId) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodDelete, path, http.NoBody)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 500 {
		return fmt.Errorf("invalid response: %d - %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	dec := json.NewDecoder(resp.Body)
	if resp.StatusCode >= 400 {
		var apiErr APIError
		if err := dec.Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	}

	return nil
}

// GetReader: Retrieve a Reader
// Gets a Reader.
func (s *ReadersService) GetReader(ctx context.Context, merchantCode string, id ReaderId, params GetReaderParams) (*Reader, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodGet, path, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 500 {
		return nil, fmt.Errorf("invalid response: %d - %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	dec := json.NewDecoder(resp.Body)
	if resp.StatusCode >= 400 {
		var apiErr APIError
		if err := dec.Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	}

	var v Reader
	if err := dec.Decode(&v); err != nil {
		return nil, fmt.Errorf("decode response: %s", err.Error())
	}

	return &v, nil
}

// UpdateReader: Update a Reader
// Updates a Reader.
func (s *ReadersService) UpdateReader(ctx context.Context, merchantCode string, id ReaderId, body UpdateReaderBody) error {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodPatch, path, buf)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 500 {
		return fmt.Errorf("invalid response: %d - %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}

	dec := json.NewDecoder(resp.Body)
	if resp.StatusCode >= 400 {
		var apiErr APIError
		if err := dec.Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	}

	return nil
}
