// Code generated by `go-sdk-gen`. DO NOT EDIT.

package readers

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"time"

	"github.com/sumup/sumup-go/client"
	"github.com/sumup/sumup-go/shared"
)

// BadGateway: 502 Bad Gateway
type BadGateway struct {
	Errors BadGatewayErrors `json:"errors"`
}

// BadGatewayErrors is a schema definition.
type BadGatewayErrors struct {
	// Fuller message giving context to error
	Detail string `json:"detail"`
}

func (e *BadGateway) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*BadGateway)(nil)

// BadRequest: 400 Bad Request
type BadRequest struct {
	Errors BadRequestErrors `json:"errors"`
}

// BadRequestErrors is a schema definition.
type BadRequestErrors struct {
	// Fuller message giving context to error
	Detail *string `json:"detail,omitempty"`
	// Key indicating type of error
	Type BadRequestErrorsType `json:"type"`
}

// BadRequestErrorsType: Key indicating type of error
type BadRequestErrorsType string

const (
	BadRequestErrorsTypeDuplicateHeaders       BadRequestErrorsType = "DUPLICATE_HEADERS"
	BadRequestErrorsTypeInvalidBearerToken     BadRequestErrorsType = "INVALID_BEARER_TOKEN"
	BadRequestErrorsTypeInvalidUserAgent       BadRequestErrorsType = "INVALID_USER_AGENT"
	BadRequestErrorsTypeNotEnoughUnpaidPayouts BadRequestErrorsType = "NOT_ENOUGH_UNPAID_PAYOUTS"
)

func (e *BadRequest) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*BadRequest)(nil)

// CreateReaderCheckoutError: Error description
type CreateReaderCheckoutError struct {
	Errors CreateReaderCheckoutErrorErrors `json:"errors"`
}

// CreateReaderCheckoutErrorErrors is a schema definition.
type CreateReaderCheckoutErrorErrors struct {
	// Error message
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderCheckoutError) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderCheckoutError)(nil)

// CreateCheckoutRequest: Reader Checkout
type CreateCheckoutRequest struct {
	// Affiliate metadata for the transaction.
	// It is a field that allow for integrators to track the source of the transaction.
	Affiliate *CreateCheckoutRequestAffiliate `json:"affiliate,omitempty"`
	// The card type of the card used for the transaction.
	// Is is required only for some countries (e.g: Brazil).
	CardType *CreateCheckoutRequestCardType `json:"card_type,omitempty"`
	// Description of the checkout to be shown in the Merchant Sales
	Description *string `json:"description,omitempty"`
	// Number of installments for the transaction.
	// It may vary according to the merchant country.
	// For example, in Brazil, the maximum number of installments is 12.
	//
	// Omit if the merchant country does support installments.
	// Otherwise, the checkout will be rejected.
	// Min: 1
	Installments *int `json:"installments,omitempty"`
	// Webhook URL to which the payment result will be sent.
	// It must be a HTTPS url.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// List of tipping rates to be displayed to the cardholder.
	// The rates are in percentage and should be between 0.01 and 0.99.
	// The list should be sorted in ascending order.
	TipRates []float32 `json:"tip_rates,omitempty"`
	// Time in seconds the cardholder has to select a tip rate.
	// If not provided, the default value is 30 seconds.
	//
	// It can only be set if `tip_rates` is provided.
	//
	// **Note**: If the target device is a Solo, it must be in version 3.3.38.0 or higher.
	// Default: 30
	// Min: 30
	// Max: 120
	TipTimeout *int `json:"tip_timeout,omitempty"`
	// Amount structure.
	//
	// The amount is represented as an integer value altogether with the currency and the minor unit.
	//
	// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	TotalAmount CreateCheckoutRequestTotalAmount `json:"total_amount"`
}

// CreateCheckoutRequestAffiliate: Affiliate metadata for the transaction.
// It is a field that allow for integrators to track the source of the transaction.
type CreateCheckoutRequestAffiliate struct {
	// Application ID of the affiliate.
	// It is a unique identifier for the application and should be set by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	AppID string `json:"app_id"`
	// Foreign transaction ID of the affiliate.
	// It is a unique identifier for the transaction.
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ForeignTransactionID string `json:"foreign_transaction_id"`
	// Key of the affiliate.
	// It is a unique identifier for the key  and should be generated by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	Key string `json:"key"`
	// Additional metadata for the transaction.
	// It is key-value object that can be associated with the transaction.
	Tags CreateCheckoutRequestAffiliateTags `json:"tags,omitempty"`
}

// CreateCheckoutRequestAffiliateTags: Additional metadata for the transaction.
// It is key-value object that can be associated with the transaction.
type CreateCheckoutRequestAffiliateTags map[string]any

// CreateCheckoutRequestCardType: The card type of the card used for the transaction.
// Is is required only for some countries (e.g: Brazil).
type CreateCheckoutRequestCardType string

const (
	CreateCheckoutRequestCardTypeCredit CreateCheckoutRequestCardType = "credit"
	CreateCheckoutRequestCardTypeDebit  CreateCheckoutRequestCardType = "debit"
)

// CreateCheckoutRequestTotalAmount: Amount structure.
//
// The amount is represented as an integer value altogether with the currency and the minor unit.
//
// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
type CreateCheckoutRequestTotalAmount struct {
	// Currency ISO 4217 code
	Currency string `json:"currency"`
	// The minor units of the currency.
	// It represents the number of decimals of the currency. For the currencies CLP, COP and HUF, the minor unit
	// is 0.
	// Min: 0
	MinorUnit int `json:"minor_unit"`
	// Integer value of the amount.
	// Min: 0
	Value int `json:"value"`
}

// CreateReaderCheckoutResponse is a schema definition.
type CreateReaderCheckoutResponse struct {
	Data CreateReaderCheckoutResponseData `json:"data"`
}

// CreateReaderCheckoutResponseData is a schema definition.
type CreateReaderCheckoutResponseData struct {
	// The client transaction ID is a unique identifier for the transaction that is generated for the client.
	//
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ClientTransactionID string `json:"client_transaction_id"`
}

// CreateReaderCheckoutUnprocessableEntity: Unprocessable entity
type CreateReaderCheckoutUnprocessableEntity struct {
	Errors CreateReaderCheckoutUnprocessableEntityErrors `json:"errors"`
}

// CreateReaderCheckoutUnprocessableEntityErrors is a schema definition.
type CreateReaderCheckoutUnprocessableEntityErrors map[string]any

func (e *CreateReaderCheckoutUnprocessableEntity) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderCheckoutUnprocessableEntity)(nil)

// CreateReaderTerminateError: Error description
type CreateReaderTerminateError struct {
	Errors CreateReaderTerminateErrorErrors `json:"errors"`
}

// CreateReaderTerminateErrorErrors is a schema definition.
type CreateReaderTerminateErrorErrors struct {
	// Error message
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderTerminateError) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderTerminateError)(nil)

// CreateReaderTerminateUnprocessableEntity: Unprocessable entity
type CreateReaderTerminateUnprocessableEntity struct {
	Errors CreateReaderTerminateUnprocessableEntityErrors `json:"errors"`
}

// CreateReaderTerminateUnprocessableEntityErrors is a schema definition.
type CreateReaderTerminateUnprocessableEntityErrors map[string]any

func (e *CreateReaderTerminateUnprocessableEntity) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderTerminateUnprocessableEntity)(nil)

// GatewayTimeout: 504 Gateway Timeout
type GatewayTimeout struct {
	Errors GatewayTimeoutErrors `json:"errors"`
}

// GatewayTimeoutErrors is a schema definition.
type GatewayTimeoutErrors struct {
	// Fuller message giving context to error
	Detail string `json:"detail"`
}

func (e *GatewayTimeout) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*GatewayTimeout)(nil)

// InternalServerError: 500 Internal Server Error
type InternalServerError struct {
	Errors InternalServerErrorErrors `json:"errors"`
}

// InternalServerErrorErrors is a schema definition.
type InternalServerErrorErrors struct {
	// Fuller message giving context to error
	Detail string `json:"detail"`
}

func (e *InternalServerError) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*InternalServerError)(nil)

// NotFound: 404 Not Found
type NotFound struct {
	Errors NotFoundErrors `json:"errors"`
}

// NotFoundErrors is a schema definition.
type NotFoundErrors struct {
	// Fuller message giving context to error
	Detail string `json:"detail"`
}

func (e *NotFound) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*NotFound)(nil)

// Reader: A physical card reader device that can accept in-person payments.
type Reader struct {
	// The timestamp of when the reader was created.
	CreatedAt time.Time `json:"created_at"`
	// Information about the underlying physical device.
	Device ReaderDevice `json:"device"`
	// Unique identifier of the object.
	//
	// Note that this identifies the instance of the physical devices pairing with your SumUp account. If you [delete](https://developer.sumup.com/api/readers/delete-reader)
	// a reader, and pair the device again, the ID will be different. Do not use this ID to refer to a physical device.
	//
	// Min length: 30
	// Max length: 30
	ID ReaderID `json:"id"`
	// Set of user-defined key-value pairs attached to the object. Partial updates are not supported. When updating, always
	// submit whole metadata. Maximum of 64 parameters are allowed in the object.
	// Max properties: 64
	Metadata shared.Metadata `json:"metadata,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name ReaderName `json:"name"`
	// The status of the reader object gives information about the current state of the reader.
	//
	// Possible values:
	//
	// - `unknown` - The reader status is unknown.
	// - `processing` - The reader is created and waits for the physical device to confirm the pairing.
	// - `paired` - The reader is paired with a merchant account and can be used with SumUp APIs.
	// - `expired` - The pairing is expired and no longer usable with the account. The resource needs to get recreated.
	Status ReaderStatus `json:"status"`
	// The timestamp of when the reader was last updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ReaderDevice: Information about the underlying physical device.
type ReaderDevice struct {
	// A unique identifier of the physical device (e.g. serial number).
	Identifier string `json:"identifier"`
	// Identifier of the model of the device.
	Model ReaderDeviceModel `json:"model"`
}

// ReaderDeviceModel: Identifier of the model of the device.
type ReaderDeviceModel string

const (
	ReaderDeviceModelSolo        ReaderDeviceModel = "solo"
	ReaderDeviceModelVirtualSolo ReaderDeviceModel = "virtual-solo"
)

// ReaderID: Unique identifier of the object.
//
// Note that this identifies the instance of the physical devices pairing with your SumUp account. If you [delete](https://developer.sumup.com/api/readers/delete-reader)
// a reader, and pair the device again, the ID will be different. Do not use this ID to refer to a physical device.
//
// Min length: 30
// Max length: 30
type ReaderID string

// ReaderName: Custom human-readable, user-defined name for easier identification of the reader.
// Max length: 500
type ReaderName string

// ReaderPairingCode: The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp
// Device after initiating the pairing. It is used to link the physical device to the created pairing.
// Min length: 8
// Max length: 9
type ReaderPairingCode string

// ReaderStatus: The status of the reader object gives information about the current state of the reader.
//
// Possible values:
//
// - `unknown` - The reader status is unknown.
// - `processing` - The reader is created and waits for the physical device to confirm the pairing.
// - `paired` - The reader is paired with a merchant account and can be used with SumUp APIs.
// - `expired` - The pairing is expired and no longer usable with the account. The resource needs to get recreated.
type ReaderStatus string

const (
	ReaderStatusExpired    ReaderStatus = "expired"
	ReaderStatusPaired     ReaderStatus = "paired"
	ReaderStatusProcessing ReaderStatus = "processing"
	ReaderStatusUnknown    ReaderStatus = "unknown"
)

// StatusResponse: Status of a device
type StatusResponse struct {
	Data StatusResponseData `json:"data"`
}

// StatusResponseData is a schema definition.
type StatusResponseData struct {
	// Battery level percentage
	// Min: 0
	// Max: 100
	BatteryLevel *float32 `json:"battery_level,omitempty"`
	// Battery temperature in Celsius
	BatteryTemperature *int `json:"battery_temperature,omitempty"`
	// Type of connection used by the device
	ConnectionType *StatusResponseDataConnectionType `json:"connection_type,omitempty"`
	// Firmware version of the device
	FirmwareVersion *string `json:"firmware_version,omitempty"`
	// Timestamp of the last activity from the device
	LastActivity *time.Time `json:"last_activity,omitempty"`
	// Latest state of the device
	State *StatusResponseDataState `json:"state,omitempty"`
	// Status of a device
	Status StatusResponseDataStatus `json:"status"`
}

// StatusResponseDataConnectionType: Type of connection used by the device
type StatusResponseDataConnectionType string

const (
	StatusResponseDataConnectionTypeBtle StatusResponseDataConnectionType = "btle"
	StatusResponseDataConnectionTypeEdge StatusResponseDataConnectionType = "edge"
	StatusResponseDataConnectionTypeGprs StatusResponseDataConnectionType = "gprs"
	StatusResponseDataConnectionTypeLte  StatusResponseDataConnectionType = "lte"
	StatusResponseDataConnectionTypeUmts StatusResponseDataConnectionType = "umts"
	StatusResponseDataConnectionTypeUsb  StatusResponseDataConnectionType = "usb"
	StatusResponseDataConnectionTypeWiFi StatusResponseDataConnectionType = "Wi-Fi"
)

// StatusResponseDataState: Latest state of the device
type StatusResponseDataState string

const (
	StatusResponseDataStateIdle                StatusResponseDataState = "IDLE"
	StatusResponseDataStateSelectingTip        StatusResponseDataState = "SELECTING_TIP"
	StatusResponseDataStateUpdatingFirmware    StatusResponseDataState = "UPDATING_FIRMWARE"
	StatusResponseDataStateWaitingForCard      StatusResponseDataState = "WAITING_FOR_CARD"
	StatusResponseDataStateWaitingForPIN       StatusResponseDataState = "WAITING_FOR_PIN"
	StatusResponseDataStateWaitingForSignature StatusResponseDataState = "WAITING_FOR_SIGNATURE"
)

// StatusResponseDataStatus: Status of a device
type StatusResponseDataStatus string

const (
	StatusResponseDataStatusOffline StatusResponseDataStatus = "OFFLINE"
	StatusResponseDataStatusOnline  StatusResponseDataStatus = "ONLINE"
)

// Unauthorized: 401 Unauthorized
type Unauthorized struct {
	Errors UnauthorizedErrors `json:"errors"`
}

// UnauthorizedErrors is a schema definition.
type UnauthorizedErrors struct {
	// Fuller message giving context to error
	Detail *string `json:"detail,omitempty"`
	// Key indicating type of error
	Type UnauthorizedErrorsType `json:"type"`
}

// UnauthorizedErrorsType: Key indicating type of error
type UnauthorizedErrorsType string

const (
	UnauthorizedErrorsTypeInvalidAccessToken UnauthorizedErrorsType = "INVALID_ACCESS_TOKEN"
	UnauthorizedErrorsTypeInvalidPassword    UnauthorizedErrorsType = "INVALID_PASSWORD"
)

func (e *Unauthorized) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*Unauthorized)(nil)

// Create is a schema definition.
type Create struct {
	// Set of user-defined key-value pairs attached to the object. Partial updates are not supported. When updating, always
	// submit whole metadata. Maximum of 64 parameters are allowed in the object.
	// Max properties: 64
	Metadata shared.Metadata `json:"metadata,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name ReaderName `json:"name"`
	// The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiating
	// the pairing. It is used to link the physical device to the created pairing.
	// Min length: 8
	// Max length: 9
	PairingCode ReaderPairingCode `json:"pairing_code"`
}

// CreateCheckout: Reader Checkout
type CreateCheckout struct {
	// Affiliate metadata for the transaction.
	// It is a field that allow for integrators to track the source of the transaction.
	Affiliate *CreateCheckoutAffiliate `json:"affiliate,omitempty"`
	// The card type of the card used for the transaction.
	// Is is required only for some countries (e.g: Brazil).
	CardType *CreateCheckoutCardType `json:"card_type,omitempty"`
	// Description of the checkout to be shown in the Merchant Sales
	Description *string `json:"description,omitempty"`
	// Number of installments for the transaction.
	// It may vary according to the merchant country.
	// For example, in Brazil, the maximum number of installments is 12.
	//
	// Omit if the merchant country does support installments.
	// Otherwise, the checkout will be rejected.
	// Min: 1
	Installments *int `json:"installments,omitempty"`
	// Webhook URL to which the payment result will be sent.
	// It must be a HTTPS url.
	// Format: uri
	ReturnURL *string `json:"return_url,omitempty"`
	// List of tipping rates to be displayed to the cardholder.
	// The rates are in percentage and should be between 0.01 and 0.99.
	// The list should be sorted in ascending order.
	TipRates []float32 `json:"tip_rates,omitempty"`
	// Time in seconds the cardholder has to select a tip rate.
	// If not provided, the default value is 30 seconds.
	//
	// It can only be set if `tip_rates` is provided.
	//
	// **Note**: If the target device is a Solo, it must be in version 3.3.38.0 or higher.
	// Default: 30
	// Min: 30
	// Max: 120
	TipTimeout *int `json:"tip_timeout,omitempty"`
	// Amount structure.
	//
	// The amount is represented as an integer value altogether with the currency and the minor unit.
	//
	// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	TotalAmount CreateCheckoutTotalAmount `json:"total_amount"`
}

// CreateCheckoutAffiliate: Affiliate metadata for the transaction.
// It is a field that allow for integrators to track the source of the transaction.
type CreateCheckoutAffiliate struct {
	// Application ID of the affiliate.
	// It is a unique identifier for the application and should be set by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	AppID string `json:"app_id"`
	// Foreign transaction ID of the affiliate.
	// It is a unique identifier for the transaction.
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ForeignTransactionID string `json:"foreign_transaction_id"`
	// Key of the affiliate.
	// It is a unique identifier for the key  and should be generated by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	Key string `json:"key"`
	// Additional metadata for the transaction.
	// It is key-value object that can be associated with the transaction.
	Tags CreateCheckoutAffiliateTags `json:"tags,omitempty"`
}

// CreateCheckoutAffiliateTags: Additional metadata for the transaction.
// It is key-value object that can be associated with the transaction.
type CreateCheckoutAffiliateTags map[string]any

// CreateCheckoutCardType: The card type of the card used for the transaction.
// Is is required only for some countries (e.g: Brazil).
type CreateCheckoutCardType string

const (
	CreateCheckoutCardTypeCredit CreateCheckoutCardType = "credit"
	CreateCheckoutCardTypeDebit  CreateCheckoutCardType = "debit"
)

// CreateCheckoutTotalAmount: Amount structure.
//
// The amount is represented as an integer value altogether with the currency and the minor unit.
//
// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
type CreateCheckoutTotalAmount struct {
	// Currency ISO 4217 code
	Currency string `json:"currency"`
	// The minor units of the currency.
	// It represents the number of decimals of the currency. For the currencies CLP, COP and HUF, the minor unit
	// is 0.
	// Min: 0
	MinorUnit int `json:"minor_unit"`
	// Integer value of the amount.
	// Min: 0
	Value int `json:"value"`
}

// Update is a schema definition.
type Update struct {
	// Set of user-defined key-value pairs attached to the object. Partial updates are not supported. When updating, always
	// submit whole metadata. Maximum of 64 parameters are allowed in the object.
	// Max properties: 64
	Metadata shared.Metadata `json:"metadata,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name *ReaderName `json:"name,omitempty"`
}

// GetStatusParams are query parameters for GetReaderStatus.
type GetStatusParams struct {
	Accept        string
	Authorization string
	ContentType   string
}

// QueryValues converts [GetStatusParams] into [url.Values].
func (p *GetStatusParams) QueryValues() url.Values {
	q := make(url.Values)

	q.Set("Accept", p.Accept)

	q.Set("Authorization", p.Authorization)

	q.Set("Content-Type", p.ContentType)

	return q
}

// GetParams are query parameters for GetReader.
type GetParams struct {
	// Return the reader only if it has been modified after the specified timestamp given in the headers.
	//
	// Timestamps are accepted in the following formats:
	//
	//  - HTTP Standard: [IMF format (RFC 5322)](https://www.rfc-editor.org/rfc/rfc5322#section-3.3), sometimes also
	// referred to as [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1).
	//  - RFC 3339: Used for timestamps in JSON payloads on this API.
	IfModifiedSince *string
}

// QueryValues converts [GetParams] into [url.Values].
func (p *GetParams) QueryValues() url.Values {
	q := make(url.Values)

	if p.IfModifiedSince != nil {
		q.Set("If-Modified-Since", *p.IfModifiedSince)
	}

	return q
}

// ListReaders200Response is a schema definition.
type ListReaders200Response struct {
	Items []Reader `json:"items"`
}

type ReadersService struct {
	c *client.Client
}

func NewReadersService(c *client.Client) *ReadersService {
	return &ReadersService{c: c}
}

// List all readers of the merchant.
func (s *ReadersService) List(ctx context.Context, merchantCode string) (*ListReaders200Response, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers", merchantCode)

	resp, err := s.c.Call(ctx, http.MethodGet, path)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v ListReaders200Response
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Create a new Reader for the merchant account.
func (s *ReadersService) Create(ctx context.Context, merchantCode string, body Create) (*Reader, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers", merchantCode)

	resp, err := s.c.Call(ctx, http.MethodPost, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v Reader
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr shared.Problem
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr shared.Problem
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusConflict:
		var apiErr shared.Problem
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Terminate a Reader Checkout stops the current transaction on the target device.
//
// This process is asynchronous and the actual termination may take some time to be performed on the device.
//
// There are some caveats when using this endpoint:
// * The target device must be online, otherwise terminate won't be accepted
// * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting
// for PIN, etc.
// * There is no confirmation of the termination.
//
// If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status
// will be sent as `failed` to the provided URL.
//
// **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
func (s *ReadersService) TerminateCheckout(ctx context.Context, merchantCode string, readerID string) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/terminate", merchantCode, readerID)

	resp, err := s.c.Call(ctx, http.MethodPost, path)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusAccepted:
		return nil
	case http.StatusBadRequest:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	case http.StatusUnauthorized:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	case http.StatusUnprocessableEntity:
		var apiErr CreateReaderTerminateUnprocessableEntity
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	case http.StatusInternalServerError:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	case http.StatusBadGateway:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	case http.StatusGatewayTimeout:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	default:
		return fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Provides the last known status for a Reader.
//
// This endpoint allows you to retrieve updates from the connected card reader, including the current screen being
// displayed during the payment process and the device status (battery level, connectivity, and update state).
//
// # Supported States
//
// * `IDLE` – Reader ready for next transaction
// * `SELECTING_TIP` – Waiting for tip input
// * `WAITING_FOR_CARD` – Awaiting card insert/tap
// * `WAITING_FOR_PIN` – Waiting for PIN entry
// * `WAITING_FOR_SIGNATURE` – Waiting for customer signature
// * `UPDATING_FIRMWARE` – Firmware update in progress
//
// # Device Status
//
// * `ONLINE` – Device connected and operational
// * `OFFLINE` – Device disconnected (last state persisted)
//
// **Note**: If the target device is a Solo, it must be in version 3.3.39.0 or higher.
func (s *ReadersService) GetStatus(ctx context.Context, merchantCode string, readerID string, params GetStatusParams) (*StatusResponse, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/status", merchantCode, readerID)

	resp, err := s.c.Call(ctx, http.MethodGet, path, client.WithQueryValues(params.QueryValues()))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v StatusResponse
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr BadRequest
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr Unauthorized
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr NotFound
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusInternalServerError:
		var apiErr InternalServerError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusBadGateway:
		var apiErr BadGateway
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusGatewayTimeout:
		var apiErr GatewayTimeout
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Creates a Checkout for a Reader.
//
// This process is asynchronous and the actual transaction may take some time to be stared on the device.
//
// There are some caveats when using this endpoint:
// * The target device must be online, otherwise checkout won't be accepted
// * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During
// this time, any other checkout for the same device will be rejected.
//
// **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
func (s *ReadersService) CreateCheckout(ctx context.Context, merchantCode string, readerID string, body CreateCheckout) (*CreateReaderCheckoutResponse, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/checkout", merchantCode, readerID)

	resp, err := s.c.Call(ctx, http.MethodPost, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v CreateReaderCheckoutResponse
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnprocessableEntity:
		var apiErr CreateReaderCheckoutUnprocessableEntity
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusInternalServerError:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusBadGateway:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusGatewayTimeout:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Delete a reader.
func (s *ReadersService) Delete(ctx context.Context, merchantCode string, id ReaderID) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	resp, err := s.c.Call(ctx, http.MethodDelete, path)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		return nil
	case http.StatusNotFound:
		var apiErr shared.Problem
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	default:
		return fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Retrieve a Reader.
func (s *ReadersService) Get(ctx context.Context, merchantCode string, id ReaderID, params GetParams) (*Reader, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	resp, err := s.c.Call(ctx, http.MethodGet, path, client.WithQueryValues(params.QueryValues()))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v Reader
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusNotFound:
		var apiErr shared.Problem
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Update a Reader.
func (s *ReadersService) Update(ctx context.Context, merchantCode string, id ReaderID, body Update) (*Reader, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	resp, err := s.c.Call(ctx, http.MethodPatch, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v Reader
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusForbidden:
		var apiErr shared.Problem
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusNotFound:
		var apiErr shared.Problem
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}
