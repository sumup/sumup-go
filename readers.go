// Code generated by `go-sdk-gen`. DO NOT EDIT.
package sumup

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"time"
)

// Affiliate: Affiliate metadata for the transaction.
// It is an optional field that allow for integrators to track the source of the transaction.
type Affiliate struct {
	// Application ID of the affiliate.
	// It is a unique identifier for the application and should be set by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	AppId string `json:"app_id"`
	// Foreign transaction ID of the affiliate.
	// It is a unique identifier for the transaction.
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ForeignTransactionId string `json:"foreign_transaction_id"`
	// Key of the affiliate.
	// It is a unique identifier for the key  and should be generated by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	//
	// Format: uuid
	Key string `json:"key"`
	// Additional metadata for the transaction.
	// It is key-value object that can be associated with the transaction.
	Tags *AffiliateTags `json:"tags,omitempty"`
}

// AffiliateTags: Additional metadata for the transaction.
// It is key-value object that can be associated with the transaction.
type AffiliateTags map[string]any

// CreateReaderCheckout: Reader Checkout
type CreateReaderCheckout struct {
	// Affiliate metadata for the transaction.
	// It is an optional field that allow for integrators to track the source of the transaction.
	Affiliate *Affiliate `json:"affiliate,omitempty"`
	// The card type of the card used for the transaction.
	// Is is required only for some countries (e.g: Brazil).
	CardType *CreateReaderCheckoutCardType `json:"card_type,omitempty"`
	// Description of the checkout to be shown in the Merchant Sales
	Description *string `json:"description,omitempty"`
	// Number of installments for the transaction.
	// It may vary according to the merchant country.
	// For example, in Brazil, the maximum number of installments is 12.
	Installments *int `json:"installments,omitempty"`
	// Webhook URL to which the payment result will be sent.
	// It must be a HTTPS url.
	// Format: uri
	ReturnUrl *string `json:"return_url,omitempty"`
	// List of tipping rates to be displayed to the cardholder.
	// The rates are in percentage and should be between 0.01 and 0.99.
	// The list should be sorted in ascending order.
	TipRates *[]float64 `json:"tip_rates,omitempty"`
	// Amount of the transaction.
	// The amount is represented as an integer value altogether with the currency and the minor unit.
	// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	TotalAmount CreateReaderCheckoutAmount `json:"total_amount"`
}

// CreateReaderCheckoutCardType: The card type of the card used for the transaction.
// Is is required only for some countries (e.g: Brazil).
type CreateReaderCheckoutCardType string

const (
	CreateReaderCheckoutCardTypeCredit CreateReaderCheckoutCardType = "credit"
	CreateReaderCheckoutCardTypeDebit  CreateReaderCheckoutCardType = "debit"
)

// CreateReaderCheckoutAmount: Amount of the transaction.
// The amount is represented as an integer value altogether with the currency and the minor unit.
// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
type CreateReaderCheckoutAmount struct {
	// Currency ISO 4217 code
	Currency string `json:"currency"`
	// The minor units of the currency. It represents the number of decimals of the currency.
	// For the currencies CLP, COP and HUF, the minor unit is 0.
	MinorUnit int `json:"minor_unit"`
	// Total amount of the transaction.
	// It must be a positive integer.
	Value int `json:"value"`
}

// Meta: Set of user-defined key-value pairs attached to the object.
// Max properties: 50
type Meta map[string]any

// Reader: A physical card reader device that can accept in-person payments.
type Reader struct {
	// Reader creation timestamp.
	CreatedAt time.Time `json:"created_at"`
	// Information about the underlying physical device.
	Device ReaderDevice `json:"device"`
	// Unique identifier of the object.
	//
	// Note that this identifies the instance of the physical devices pairing with your SumUp account.
	//
	// If you DELETE a reader, and pair the device again, the ID will be different. Do not use this ID to refer to
	// a physical device.
	// Min length: 30
	// Max length: 30
	Id ReaderId `json:"id"`
	// Set of user-defined key-value pairs attached to the object.
	// Max properties: 50
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name ReaderName `json:"name"`
	// The status of the reader object gives information about the current state of the reader.
	//
	// Possible values:
	//
	// - `unknown` - The reader status is unknown.
	// - `processing` - The reader is created and waits for the physical device to confirm the pairing.
	// - `paired` - The reader is paired with a merchant account and can be used with SumUp APIs.
	// - `expired` - The pairing is expired and no longer usable with the account. The resource needs to get recreated
	Status ReaderStatus `json:"status"`
	// Reader last-modification timestamp.
	UpdatedAt time.Time `json:"updated_at"`
}

// ReaderDevice: Information about the underlying physical device.
type ReaderDevice struct {
	// A unique identifier of the physical device (e.g. serial number).
	Identifier string `json:"identifier"`
	// Identifier of the model of the device.
	Model ReaderDeviceModel `json:"model"`
}

// ReaderDeviceModel: Identifier of the model of the device.
type ReaderDeviceModel string

const (
	ReaderDeviceModelSolo        ReaderDeviceModel = "solo"
	ReaderDeviceModelVirtualSolo ReaderDeviceModel = "virtual-solo"
)

// ReaderId: Unique identifier of the object.
//
// Note that this identifies the instance of the physical devices pairing with your SumUp account.
//
// If you DELETE a reader, and pair the device again, the ID will be different. Do not use this ID to refer to
// a physical device.
//
// Min length: 30
// Max length: 30
type ReaderId string

// ReaderName: Custom human-readable, user-defined name for easier identification of the reader.
//
// Max length: 500
type ReaderName string

// ReaderPairingCode: The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp
// Device after initiating the pairing.
// It is used to link the physical device to the created pairing.
//
// Min length: 8
// Max length: 9
type ReaderPairingCode string

// ReaderStatus: The status of the reader object gives information about the current state of the reader.
//
// Possible values:
//
// - `unknown` - The reader status is unknown.
// - `processing` - The reader is created and waits for the physical device to confirm the pairing.
// - `paired` - The reader is paired with a merchant account and can be used with SumUp APIs.
// - `expired` - The pairing is expired and no longer usable with the account. The resource needs to get recreated
type ReaderStatus string

const (
	ReaderStatusExpired    ReaderStatus = "expired"
	ReaderStatusPaired     ReaderStatus = "paired"
	ReaderStatusProcessing ReaderStatus = "processing"
	ReaderStatusUnknown    ReaderStatus = "unknown"
)

// CreateReaderBody is a schema definition.
type CreateReaderBody struct {
	// Set of user-defined key-value pairs attached to the object.
	// Max properties: 50
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name *ReaderName `json:"name,omitempty"`
	// The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiating
	// the pairing.
	// It is used to link the physical device to the created pairing.
	// Min length: 8
	// Max length: 9
	PairingCode ReaderPairingCode `json:"pairing_code"`
}

// CreateReaderCheckoutBody: Reader Checkout
type CreateReaderCheckoutBody struct {
	// Affiliate metadata for the transaction.
	// It is an optional field that allow for integrators to track the source of the transaction.
	Affiliate *Affiliate `json:"affiliate,omitempty"`
	// The card type of the card used for the transaction.
	// Is is required only for some countries (e.g: Brazil).
	CardType *CreateReaderCheckoutBodyCardType `json:"card_type,omitempty"`
	// Description of the checkout to be shown in the Merchant Sales
	Description *string `json:"description,omitempty"`
	// Number of installments for the transaction.
	// It may vary according to the merchant country.
	// For example, in Brazil, the maximum number of installments is 12.
	Installments *int `json:"installments,omitempty"`
	// Webhook URL to which the payment result will be sent.
	// It must be a HTTPS url.
	// Format: uri
	ReturnUrl *string `json:"return_url,omitempty"`
	// List of tipping rates to be displayed to the cardholder.
	// The rates are in percentage and should be between 0.01 and 0.99.
	// The list should be sorted in ascending order.
	TipRates *[]float64 `json:"tip_rates,omitempty"`
	// Amount of the transaction.
	// The amount is represented as an integer value altogether with the currency and the minor unit.
	// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	TotalAmount CreateReaderCheckoutAmount `json:"total_amount"`
}

// CreateReaderCheckoutBodyCardType: The card type of the card used for the transaction.
// Is is required only for some countries (e.g: Brazil).
type CreateReaderCheckoutBodyCardType string

const (
	CreateReaderCheckoutBodyCardTypeCredit CreateReaderCheckoutBodyCardType = "credit"
	CreateReaderCheckoutBodyCardTypeDebit  CreateReaderCheckoutBodyCardType = "debit"
)

// UpdateReaderBody is a schema definition.
type UpdateReaderBody struct {
	// Set of user-defined key-value pairs attached to the object.
	// Max properties: 50
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name *ReaderName `json:"name,omitempty"`
}

// GetReaderParams: query parameters for GetReader
type GetReaderParams struct {
	// Return the reader only if it has been modified after the specified timestamp given in the headers.
	//
	// Timestamps are accepted in the following formats:
	//  - HTTP Standard: [IMF format (RFC 5322)](https://www.rfc-editor.org/rfc/rfc5322#section-3.3), sometimes also
	// referred to as [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1).
	//  - RFC 3339: Used for timestamps in JSON payloads on this API.
	IfModifiedSince *string
}

// QueryValues converts [GetReaderParams] into [url.Values].
func (p *GetReaderParams) QueryValues() url.Values {
	q := make(url.Values)

	if p.IfModifiedSince != nil {
		q.Set("If-Modified-Since", *p.IfModifiedSince)
	}

	return q
}

// ListReaders200Response is a schema definition.
type ListReaders200Response struct {
	Items []Reader `json:"items"`
}

var _ error = (*CreateReaderTerminate422Response)(nil)

// CreateReaderTerminate422Response is a schema definition.
type CreateReaderTerminate422Response struct {
	Errors *CreateReaderTerminate422ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderTerminate422ResponseErrors is a schema definition.
type CreateReaderTerminate422ResponseErrors map[string]any

func (e *CreateReaderTerminate422Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderTerminate500Response)(nil)

// CreateReaderTerminate500Response is a schema definition.
type CreateReaderTerminate500Response struct {
	Errors *CreateReaderTerminate500ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderTerminate500ResponseErrors is a schema definition.
type CreateReaderTerminate500ResponseErrors struct {
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderTerminate500Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderTerminate502Response)(nil)

// CreateReaderTerminate502Response is a schema definition.
type CreateReaderTerminate502Response struct {
	Errors *CreateReaderTerminate502ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderTerminate502ResponseErrors is a schema definition.
type CreateReaderTerminate502ResponseErrors struct {
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderTerminate502Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderTerminate504Response)(nil)

// CreateReaderTerminate504Response is a schema definition.
type CreateReaderTerminate504Response struct {
	Errors *CreateReaderTerminate504ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderTerminate504ResponseErrors is a schema definition.
type CreateReaderTerminate504ResponseErrors struct {
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderTerminate504Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

// CreateReaderCheckout201Response is a schema definition.
type CreateReaderCheckout201Response struct {
	Data *CreateReaderCheckout201ResponseData `json:"data,omitempty"`
}

// CreateReaderCheckout201ResponseData is a schema definition.
type CreateReaderCheckout201ResponseData struct {
	// The client transaction ID is a unique identifier for the transaction that is generated for the client.
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	// Format: uuid
	ClientTransactionId *string `json:"client_transaction_id,omitempty"`
}

var _ error = (*CreateReaderCheckout400Response)(nil)

// CreateReaderCheckout400Response is a schema definition.
type CreateReaderCheckout400Response struct {
	Errors *CreateReaderCheckout400ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderCheckout400ResponseErrors is a schema definition.
type CreateReaderCheckout400ResponseErrors struct {
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderCheckout400Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderCheckout422Response)(nil)

// CreateReaderCheckout422Response is a schema definition.
type CreateReaderCheckout422Response struct {
	Errors *CreateReaderCheckout422ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderCheckout422ResponseErrors is a schema definition.
type CreateReaderCheckout422ResponseErrors map[string]any

func (e *CreateReaderCheckout422Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderCheckout500Response)(nil)

// CreateReaderCheckout500Response is a schema definition.
type CreateReaderCheckout500Response struct {
	Errors *CreateReaderCheckout500ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderCheckout500ResponseErrors is a schema definition.
type CreateReaderCheckout500ResponseErrors struct {
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderCheckout500Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderCheckout502Response)(nil)

// CreateReaderCheckout502Response is a schema definition.
type CreateReaderCheckout502Response struct {
	Errors *CreateReaderCheckout502ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderCheckout502ResponseErrors is a schema definition.
type CreateReaderCheckout502ResponseErrors struct {
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderCheckout502Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderCheckout504Response)(nil)

// CreateReaderCheckout504Response is a schema definition.
type CreateReaderCheckout504Response struct {
	Errors *CreateReaderCheckout504ResponseErrors `json:"errors,omitempty"`
}

// CreateReaderCheckout504ResponseErrors is a schema definition.
type CreateReaderCheckout504ResponseErrors struct {
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderCheckout504Response) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

type ReadersService service

// List: List Readers
// Returns list of all readers of the merchant.
func (s *ReadersService) List(ctx context.Context, merchantCode string) (*ListReaders200Response, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers", merchantCode)

	req, err := s.client.NewRequest(ctx, http.MethodGet, path, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v ListReaders200Response
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Create: Create a Reader
// Create a new reader linked to the merchant account.
func (s *ReadersService) Create(ctx context.Context, merchantCode string, body CreateReaderBody) (*Reader, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	path := fmt.Sprintf("/v0.1/merchants/%v/readers", merchantCode)

	req, err := s.client.NewRequest(ctx, http.MethodPost, path, buf)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v Reader
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// TerminateCheckout: Create a Reader Terminate action
// Create a Terminate action for a Reader.
//
// It stops the current transaction on the target device.
//
// This process is asynchronous and the actual termination may take some time to be performed on the device.
//
// There are some caveats when using this endpoint:
// * The target device must be online, otherwise terminate won't be accepted
// * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting
// for PIN, etc.
// * There is no confirmation of the termination.
//
// If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status
// will be sent as `failed` to the provided URL.
//
// **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
func (s *ReadersService) TerminateCheckout(ctx context.Context, merchantCode string, id string) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/terminate", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodPost, path, http.NoBody)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusAccepted:
		return nil
	case http.StatusUnprocessableEntity:
		var apiErr CreateReaderTerminate422Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	case http.StatusInternalServerError:
		var apiErr CreateReaderTerminate500Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	case http.StatusBadGateway:
		var apiErr CreateReaderTerminate502Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	case http.StatusGatewayTimeout:
		var apiErr CreateReaderTerminate504Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("read error response: %s", err.Error())
		}

		return &apiErr
	default:
		return fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// CreateCheckout: Create a Reader Checkout
// Create a Checkout for a Reader.
//
// This process is asynchronous and the actual transaction may take some time to be stared on the device.
//
// There are some caveats when using this endpoint:
// * The target device must be online, otherwise checkout won't be accepted
// * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During
// this time, any other checkout for the same device will be rejected.
//
// **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
func (s *ReadersService) CreateCheckout(ctx context.Context, merchantCode string, id string, body CreateReaderCheckoutBody) (*CreateReaderCheckout201Response, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/checkout", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodPost, path, buf)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v CreateReaderCheckout201Response
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr CreateReaderCheckout400Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnprocessableEntity:
		var apiErr CreateReaderCheckout422Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusInternalServerError:
		var apiErr CreateReaderCheckout500Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusBadGateway:
		var apiErr CreateReaderCheckout502Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusGatewayTimeout:
		var apiErr CreateReaderCheckout504Response
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// DeleteReader: Delete a reader
// Deletes a Reader.
func (s *ReadersService) DeleteReader(ctx context.Context, merchantCode string, id ReaderId) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodDelete, path, http.NoBody)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		return nil
	default:
		return fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Get: Retrieve a Reader
// Gets a Reader.
func (s *ReadersService) Get(ctx context.Context, merchantCode string, id ReaderId, params GetReaderParams) (*Reader, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodGet, path, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	req.URL.RawQuery = params.QueryValues().Encode()

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v Reader
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		return nil, errors.New("Malformed request.")
	case http.StatusNotFound:
		return nil, errors.New("The requested Reader resource does not exists.")
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Update: Update a Reader
// Updates a Reader.
func (s *ReadersService) Update(ctx context.Context, merchantCode string, id ReaderId, body UpdateReaderBody) error {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	req, err := s.client.NewRequest(ctx, http.MethodPatch, path, buf)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNotModified:
		return errors.New("The update request was successful, but the reader didn't get updated.")
	case http.StatusForbidden:
		return errors.New("The reader is not linked to the merchant account.")
	default:
		return fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}
