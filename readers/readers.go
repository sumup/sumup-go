// Code generated by `go-sdk-gen`. DO NOT EDIT.

package readers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"time"

	"github.com/sumup/sumup-go/client"
)

// CreateReaderCheckoutError: Error description
type CreateReaderCheckoutError struct {
	Errors CreateReaderCheckoutErrorErrors `json:"errors"`
}

// CreateReaderCheckoutErrorErrors is a schema definition.
type CreateReaderCheckoutErrorErrors struct {
	// Error message
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderCheckoutError) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderCheckoutError)(nil)

// CreateReaderCheckoutRequest: Reader Checkout
type CreateReaderCheckoutRequest struct {
	// Affiliate metadata for the transaction.
	// It is a field that allow for integrators to track the source of the transaction.
	Affiliate *CreateReaderCheckoutRequestAffiliate `json:"affiliate,omitempty"`
	// The card type of the card used for the transaction.
	// Is is required only for some countries (e.g: Brazil).
	CardType *CreateReaderCheckoutRequestCardType `json:"card_type,omitempty"`
	// Description of the checkout to be shown in the Merchant Sales
	Description *string `json:"description,omitempty"`
	// Number of installments for the transaction.
	// It may vary according to the merchant country.
	// For example, in Brazil, the maximum number of installments is 12.
	Installments *int `json:"installments,omitempty"`
	// Webhook URL to which the payment result will be sent.
	// It must be a HTTPS url.
	// Format: uri
	ReturnUrl *string `json:"return_url,omitempty"`
	// List of tipping rates to be displayed to the cardholder.
	// The rates are in percentage and should be between 0.01 and 0.99.
	// The list should be sorted in ascending order.
	TipRates *[]float64 `json:"tip_rates,omitempty"`
	// Time in seconds the cardholder has to select a tip rate.
	// If not provided, the default value is 30 seconds.
	//
	// It can only be set if `tip_rates` is provided.
	//
	// **Note**: If the target device is a Solo, it must be in version 3.3.38.0 or higher.
	// Default: 30
	// Min: 30
	// Max: 120
	TipTimeout *int `json:"tip_timeout,omitempty"`
	// Amount structure.
	//
	// The amount is represented as an integer value altogether with the currency and the minor unit.
	//
	// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	TotalAmount CreateReaderCheckoutRequestTotalAmount `json:"total_amount"`
}

// CreateReaderCheckoutRequestAffiliate: Affiliate metadata for the transaction.
// It is a field that allow for integrators to track the source of the transaction.
type CreateReaderCheckoutRequestAffiliate struct {
	// Application ID of the affiliate.
	// It is a unique identifier for the application and should be set by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	AppId string `json:"app_id"`
	// Foreign transaction ID of the affiliate.
	// It is a unique identifier for the transaction.
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ForeignTransactionId string `json:"foreign_transaction_id"`
	// Key of the affiliate.
	// It is a unique identifier for the key  and should be generated by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	Key string `json:"key"`
	// Additional metadata for the transaction.
	// It is key-value object that can be associated with the transaction.
	Tags *CreateReaderCheckoutRequestAffiliateTags `json:"tags,omitempty"`
}

// CreateReaderCheckoutRequestAffiliateTags: Additional metadata for the transaction.
// It is key-value object that can be associated with the transaction.
type CreateReaderCheckoutRequestAffiliateTags map[string]any

// CreateReaderCheckoutRequestCardType: The card type of the card used for the transaction.
// Is is required only for some countries (e.g: Brazil).
type CreateReaderCheckoutRequestCardType string

const (
	CreateReaderCheckoutRequestCardTypeCredit CreateReaderCheckoutRequestCardType = "credit"
	CreateReaderCheckoutRequestCardTypeDebit  CreateReaderCheckoutRequestCardType = "debit"
)

// CreateReaderCheckoutRequestTotalAmount: Amount structure.
//
// The amount is represented as an integer value altogether with the currency and the minor unit.
//
// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
type CreateReaderCheckoutRequestTotalAmount struct {
	// Currency ISO 4217 code
	Currency string `json:"currency"`
	// The minor units of the currency.
	// It represents the number of decimals of the currency. For the currencies CLP, COP and HUF, the minor unit
	// is 0.
	// Min: 0
	MinorUnit int `json:"minor_unit"`
	// Integer value of the amount.
	// Min: 0
	Value int `json:"value"`
}

// CreateReaderCheckoutResponse is a schema definition.
type CreateReaderCheckoutResponse struct {
	Data CreateReaderCheckoutResponseData `json:"data"`
}

// CreateReaderCheckoutResponseData is a schema definition.
type CreateReaderCheckoutResponseData struct {
	// The client transaction ID is a unique identifier for the transaction that is generated for the client.
	//
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ClientTransactionId string `json:"client_transaction_id"`
}

// CreateReaderCheckoutUnprocessableEntity: Unprocessable entity
type CreateReaderCheckoutUnprocessableEntity struct {
	Errors CreateReaderCheckoutUnprocessableEntityErrors `json:"errors"`
}

// CreateReaderCheckoutUnprocessableEntityErrors is a schema definition.
type CreateReaderCheckoutUnprocessableEntityErrors map[string]any

func (e *CreateReaderCheckoutUnprocessableEntity) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderCheckoutUnprocessableEntity)(nil)

// CreateReaderTerminateError: Error description
type CreateReaderTerminateError struct {
	Errors CreateReaderTerminateErrorErrors `json:"errors"`
}

// CreateReaderTerminateErrorErrors is a schema definition.
type CreateReaderTerminateErrorErrors struct {
	// Error message
	Detail *string `json:"detail,omitempty"`
}

func (e *CreateReaderTerminateError) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderTerminateError)(nil)

// CreateReaderTerminateUnprocessableEntity: Unprocessable entity
type CreateReaderTerminateUnprocessableEntity struct {
	Errors CreateReaderTerminateUnprocessableEntityErrors `json:"errors"`
}

// CreateReaderTerminateUnprocessableEntityErrors is a schema definition.
type CreateReaderTerminateUnprocessableEntityErrors map[string]any

func (e *CreateReaderTerminateUnprocessableEntity) Error() string {
	return fmt.Sprintf("errors=%v", e.Errors)
}

var _ error = (*CreateReaderTerminateUnprocessableEntity)(nil)

// Meta: Set of user-defined key-value pairs attached to the object.
// Max properties: 50
type Meta map[string]any

// Reader: A physical card reader device that can accept in-person payments.
type Reader struct {
	// The timestamp of when the reader was created.
	CreatedAt time.Time `json:"created_at"`
	// Information about the underlying physical device.
	Device ReaderDevice `json:"device"`
	// Unique identifier of the object.
	// Note that this identifies the instance of the physical devices pairing with your SumUp account.
	// If you DELETE a reader, and pair the device again, the ID will be different. Do not use this ID to refer to
	// a physical device.
	// Min length: 30
	// Max length: 30
	Id ReaderId `json:"id"`
	// Set of user-defined key-value pairs attached to the object.
	// Max properties: 50
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name ReaderName `json:"name"`
	// The status of the reader object gives information about the current state of the reader.
	//
	// Possible values:
	//
	// - `unknown` - The reader status is unknown.
	// - `processing` - The reader is created and waits for the physical device to confirm the pairing.
	// - `paired` - The reader is paired with a merchant account and can be used with SumUp APIs.
	// - `expired` - The pairing is expired and no longer usable with the account. The resource needs to get recreated.
	Status ReaderStatus `json:"status"`
	// The timestamp of when the reader was last updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ReaderDevice: Information about the underlying physical device.
type ReaderDevice struct {
	// A unique identifier of the physical device (e.g. serial number).
	Identifier string `json:"identifier"`
	// Identifier of the model of the device.
	Model ReaderDeviceModel `json:"model"`
}

// ReaderDeviceModel: Identifier of the model of the device.
type ReaderDeviceModel string

const (
	ReaderDeviceModelSolo        ReaderDeviceModel = "solo"
	ReaderDeviceModelVirtualSolo ReaderDeviceModel = "virtual-solo"
)

// ReaderId: Unique identifier of the object.
// Note that this identifies the instance of the physical devices pairing with your SumUp account.
// If you DELETE a reader, and pair the device again, the ID will be different. Do not use this ID to refer to
// a physical device.
// Min length: 30
// Max length: 30
type ReaderId string

// ReaderName: Custom human-readable, user-defined name for easier identification of the reader.
// Max length: 500
type ReaderName string

// ReaderPairingCode: The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp
// Device after initiating the pairing. It is used to link the physical device to the created pairing.
// Min length: 8
// Max length: 9
type ReaderPairingCode string

// ReaderStatus: The status of the reader object gives information about the current state of the reader.
//
// Possible values:
//
// - `unknown` - The reader status is unknown.
// - `processing` - The reader is created and waits for the physical device to confirm the pairing.
// - `paired` - The reader is paired with a merchant account and can be used with SumUp APIs.
// - `expired` - The pairing is expired and no longer usable with the account. The resource needs to get recreated.
type ReaderStatus string

const (
	ReaderStatusExpired    ReaderStatus = "expired"
	ReaderStatusPaired     ReaderStatus = "paired"
	ReaderStatusProcessing ReaderStatus = "processing"
	ReaderStatusUnknown    ReaderStatus = "unknown"
)

// CreateReaderBody is a schema definition.
type CreateReaderBody struct {
	// Set of user-defined key-value pairs attached to the object.
	// Max properties: 50
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name *ReaderName `json:"name,omitempty"`
	// The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiating
	// the pairing. It is used to link the physical device to the created pairing.
	// Min length: 8
	// Max length: 9
	PairingCode ReaderPairingCode `json:"pairing_code"`
}

// CreateReaderCheckoutBody: Reader Checkout
type CreateReaderCheckoutBody struct {
	// Affiliate metadata for the transaction.
	// It is a field that allow for integrators to track the source of the transaction.
	Affiliate *CreateReaderCheckoutBodyAffiliate `json:"affiliate,omitempty"`
	// The card type of the card used for the transaction.
	// Is is required only for some countries (e.g: Brazil).
	CardType *CreateReaderCheckoutBodyCardType `json:"card_type,omitempty"`
	// Description of the checkout to be shown in the Merchant Sales
	Description *string `json:"description,omitempty"`
	// Number of installments for the transaction.
	// It may vary according to the merchant country.
	// For example, in Brazil, the maximum number of installments is 12.
	Installments *int `json:"installments,omitempty"`
	// Webhook URL to which the payment result will be sent.
	// It must be a HTTPS url.
	// Format: uri
	ReturnUrl *string `json:"return_url,omitempty"`
	// List of tipping rates to be displayed to the cardholder.
	// The rates are in percentage and should be between 0.01 and 0.99.
	// The list should be sorted in ascending order.
	TipRates *[]float64 `json:"tip_rates,omitempty"`
	// Time in seconds the cardholder has to select a tip rate.
	// If not provided, the default value is 30 seconds.
	//
	// It can only be set if `tip_rates` is provided.
	//
	// **Note**: If the target device is a Solo, it must be in version 3.3.38.0 or higher.
	// Default: 30
	// Min: 30
	// Max: 120
	TipTimeout *int `json:"tip_timeout,omitempty"`
	// Amount structure.
	//
	// The amount is represented as an integer value altogether with the currency and the minor unit.
	//
	// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	TotalAmount CreateReaderCheckoutBodyTotalAmount `json:"total_amount"`
}

// CreateReaderCheckoutBodyAffiliate: Affiliate metadata for the transaction.
// It is a field that allow for integrators to track the source of the transaction.
type CreateReaderCheckoutBodyAffiliate struct {
	// Application ID of the affiliate.
	// It is a unique identifier for the application and should be set by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	AppId string `json:"app_id"`
	// Foreign transaction ID of the affiliate.
	// It is a unique identifier for the transaction.
	// It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	ForeignTransactionId string `json:"foreign_transaction_id"`
	// Key of the affiliate.
	// It is a unique identifier for the key  and should be generated by the integrator in the [Affiliate Keys](https://developer.sumup.com/affiliate-keys) page.
	Key string `json:"key"`
	// Additional metadata for the transaction.
	// It is key-value object that can be associated with the transaction.
	Tags *CreateReaderCheckoutBodyAffiliateTags `json:"tags,omitempty"`
}

// CreateReaderCheckoutBodyAffiliateTags: Additional metadata for the transaction.
// It is key-value object that can be associated with the transaction.
type CreateReaderCheckoutBodyAffiliateTags map[string]any

// CreateReaderCheckoutBodyCardType: The card type of the card used for the transaction.
// Is is required only for some countries (e.g: Brazil).
type CreateReaderCheckoutBodyCardType string

const (
	CreateReaderCheckoutBodyCardTypeCredit CreateReaderCheckoutBodyCardType = "credit"
	CreateReaderCheckoutBodyCardTypeDebit  CreateReaderCheckoutBodyCardType = "debit"
)

// CreateReaderCheckoutBodyTotalAmount: Amount structure.
//
// The amount is represented as an integer value altogether with the currency and the minor unit.
//
// For example, EUR 1.00 is represented as value 100 with minor unit of 2.
type CreateReaderCheckoutBodyTotalAmount struct {
	// Currency ISO 4217 code
	Currency string `json:"currency"`
	// The minor units of the currency.
	// It represents the number of decimals of the currency. For the currencies CLP, COP and HUF, the minor unit
	// is 0.
	// Min: 0
	MinorUnit int `json:"minor_unit"`
	// Integer value of the amount.
	// Min: 0
	Value int `json:"value"`
}

// UpdateReaderBody is a schema definition.
type UpdateReaderBody struct {
	// Set of user-defined key-value pairs attached to the object.
	// Max properties: 50
	Meta *Meta `json:"meta,omitempty"`
	// Custom human-readable, user-defined name for easier identification of the reader.
	// Max length: 500
	Name *ReaderName `json:"name,omitempty"`
}

// GetReaderParams: query parameters for GetReader
type GetReaderParams struct {
	// Return the reader only if it has been modified after the specified timestamp given in the headers.
	//
	// Timestamps are accepted in the following formats:
	//
	//  - HTTP Standard: [IMF format (RFC 5322)](https://www.rfc-editor.org/rfc/rfc5322#section-3.3), sometimes also
	// referred to as [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1).
	//  - RFC 3339: Used for timestamps in JSON payloads on this API.
	IfModifiedSince *string
}

// QueryValues converts [GetReaderParams] into [url.Values].
func (p *GetReaderParams) QueryValues() url.Values {
	q := make(url.Values)

	if p.IfModifiedSince != nil {
		q.Set("If-Modified-Since", *p.IfModifiedSince)
	}

	return q
}

// ListReaders200Response is a schema definition.
type ListReaders200Response struct {
	Items []Reader `json:"items"`
}

type ReadersService struct {
	c *client.Client
}

func NewReadersService(c *client.Client) *ReadersService {
	return &ReadersService{c: c}
}

// List: List Readers
// List all readers of the merchant.
func (s *ReadersService) List(ctx context.Context, merchantCode string) (*ListReaders200Response, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers", merchantCode)

	resp, err := s.c.Call(ctx, http.MethodGet, path)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v ListReaders200Response
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Create: Create a Reader
// Create a new Reader for the merchant account.
func (s *ReadersService) Create(ctx context.Context, merchantCode string, body CreateReaderBody) (*Reader, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers", merchantCode)

	resp, err := s.c.Call(ctx, http.MethodPost, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v Reader
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// CreateReaderTerminate: Create a Reader Terminate action
// Create a Terminate action for a Reader.
//
// It stops the current transaction on the target device.
//
// This process is asynchronous and the actual termination may take some time to be performed on the device.
//
// There are some caveats when using this endpoint:
// * The target device must be online, otherwise terminate won't be accepted
// * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting
// for PIN, etc.
// * There is no confirmation of the termination.
//
// If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status
// will be sent as `failed` to the provided URL.
//
// **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
func (s *ReadersService) CreateReaderTerminate(ctx context.Context, merchantCode string, readerId string) (*CreateReaderTerminate202Response, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/terminate", merchantCode, readerId)

	resp, err := s.c.Call(ctx, http.MethodPost, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusAccepted:
		return nil, nil
	case http.StatusBadRequest:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnprocessableEntity:
		var apiErr CreateReaderTerminateUnprocessableEntity
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusInternalServerError:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusBadGateway:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusGatewayTimeout:
		var apiErr CreateReaderTerminateError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// CreateReaderCheckout: Create a Reader Checkout
// Create a Checkout for a Reader.
//
// This process is asynchronous and the actual transaction may take some time to be stared on the device.
//
// There are some caveats when using this endpoint:
// * The target device must be online, otherwise checkout won't be accepted
// * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During
// this time, any other checkout for the same device will be rejected.
//
// **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
func (s *ReadersService) CreateReaderCheckout(ctx context.Context, merchantCode string, readerId string, body CreateReaderCheckoutBody) (*CreateReaderCheckoutResponse, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v/checkout", merchantCode, readerId)

	resp, err := s.c.Call(ctx, http.MethodPost, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusCreated:
		var v CreateReaderCheckoutResponse
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusBadRequest:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnauthorized:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusUnprocessableEntity:
		var apiErr CreateReaderCheckoutUnprocessableEntity
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusInternalServerError:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusBadGateway:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	case http.StatusGatewayTimeout:
		var apiErr CreateReaderCheckoutError
		if err := json.NewDecoder(resp.Body).Decode(&apiErr); err != nil {
			return nil, fmt.Errorf("read error response: %s", err.Error())
		}

		return nil, &apiErr
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// DeleteReader: Delete a reader
// Delete a reader.
func (s *ReadersService) DeleteReader(ctx context.Context, merchantCode string, id ReaderId) error {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	resp, err := s.c.Call(ctx, http.MethodDelete, path)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		return nil
	default:
		return fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Get: Retrieve a Reader
// Retrieve a Reader.
func (s *ReadersService) Get(ctx context.Context, merchantCode string, id ReaderId, params GetReaderParams) (*Reader, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	resp, err := s.c.Call(ctx, http.MethodGet, path, client.WithQueryValues(params.QueryValues()))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v Reader
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusNotFound:
		return nil, errors.New("The requested Reader resource does not exists.")
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}

// Update: Update a Reader
// Update a Reader.
func (s *ReadersService) Update(ctx context.Context, merchantCode string, id ReaderId, body UpdateReaderBody) (*Reader, error) {
	path := fmt.Sprintf("/v0.1/merchants/%v/readers/%v", merchantCode, id)

	resp, err := s.c.Call(ctx, http.MethodPatch, path, client.WithJSONBody(body))
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var v Reader
		if err := json.NewDecoder(resp.Body).Decode(&v); err != nil {
			return nil, fmt.Errorf("decode response: %s", err.Error())
		}

		return &v, nil
	case http.StatusForbidden:
		return nil, errors.New("The reader is not linked to the merchant account.")
	default:
		return nil, fmt.Errorf("unexpected response %d: %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
}
